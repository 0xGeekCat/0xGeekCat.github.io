<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">《新时期的Node.js入门》学习日记-使用Koa2构建Web站点 | 0xGeekCat</title>
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "Mаксим0xGeekCat";
  mashiro_option.author_name = "0xGeekCat";
  mashiro_option.site_url = "https://0xgeekcat.github.io/";
  mashiro_option.v_appId = "GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz";
  mashiro_option.v_appKey = "mgOpfzbkHYqU92CV4IDlAUHQ";
  mashiro_option.mathjax = "0";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/images/Konachan.com%20ls%20black_hair%20f%20toriki%20touhou.jpg,https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/images/Konachan.com-293503-ghostblade-long_hair-red_hair-sword-tagme_character-thighhighs-weapon-wlop-scaled.jpg,https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/images/Konachan.com-298784-aeolian_wlop-barefoot-black_hair-braids-ghostblade-headdress-long_hair-ponytail-wlop-scaled.jpg,https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/images/Konachan.com%20-%20227403%20black_hair%20ghostblade%20jade_(wlop)%20japanese_clothes%20kimono%20logo%20realistic%20short_hair%20tattoo%20umbrella%20wlop.jpg,https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/images/Konachan.com-281267-aeolian_wlop-black_hair-bow_weapon-close-ghostblade-green_eyes-logo-long_hair-realistic-watermark-weapon-wink-wlop-scaled.jpg".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop filter-dim">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="https://0xgeekcat.github.io/">
          <img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/img/custom/avatar.jpg">
        </a>
      </div>
      <div class="header-info">
        <p>用来记录我大学最后生涯破釜沉舟力挽狂澜的疯狂学习历程</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="https://github.com/0xGeekCat" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/img/social/github.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=1292881925@qq.com" target="_blank" class="social-github" title="email">
                    <img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/img/social/email.svg">
                  </a>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/img/social/wechat.png">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/img/custom/wechat.jpg">
                  </div>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">Mаксим</span>
            <span class="shironeko">0xGeekCat</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/%E6%8A%80%E6%9C%AF/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/%E7%94%9F%E6%B4%BB/">
                          <i class="fa fa-file-text-o" aria-hidden="true"></i>
                          生活
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/%E8%BD%AC%E8%BD%BD/">
                          <i class="fa fa-book" aria-hidden="true"></i>
                          转载
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    书单
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/tags/%E5%B7%B2%E8%AF%BB/">
                          <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                          已读
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/%E6%9C%AA%E8%AF%BB/">
                          <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                          未读
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    关于
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          我？
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
          <header class="entry-header">
            <h1 class="entry-title">《新时期的Node.js入门》学习日记-使用Koa2构建Web站点</h1>
            <p class="entry-census">0xGeekCat&nbsp;·&nbsp;2020-9-1&nbsp;·&nbsp;<span id="busuanzi_value_page_pv"></span>次阅读</p></p>

            <hr>
          </header>
        
        <div class="entry-content">
          <h1 id="Node-Web框架的发展历程"><a href="#Node-Web框架的发展历程" class="headerlink" title="Node Web框架的发展历程"></a>Node Web框架的发展历程</h1><p>首先梳理一下Node Web框架的发展历程，从2009年到现在，最为出名的Web框架有三个</p>
<h2 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h2><p>Connect诞生于2010年，这个时间相当早，因为Node项目始于2009年，<strong>可以将Connect理解成一个Node中间件的脚手架，只提供了基本的调用逻辑，没有具体的处理逻辑</strong>，Connect的源码结构十分简单，只有一个文件，去掉注释后的代码不超过两百行</p>
<p>之所以首先提到Connect是因为它首先在Node服务器编程中引入了中间件<code>middleware</code>概念</p>
<p>中间件的概念并不新鲜，但对于当时还是一片荒芜的Node来说，中间件概念的引入有很重要的意义，因为之后产生的大多数框架都开始采用这一思路，为后面Express的诞生与繁荣打下了基础</p>
<p><strong>中间件的引入将Web开发变成不同模块间的层级调用，有助于开发者将业务逻辑拆分</strong>；此外Connect的实现已经成了某种事实的规范</p>
<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>Express框架开发的时间也很早，它继承了Connect的大部分思想，也继承了源码，其发展分为两个阶段，Express3.x与Express4.x</p>
<ul>
<li><p>在3.x及之前版本中，Express直接依赖Connect的源码，并内置不少中间件，这种做法的缺点是如果内置的中间件更新，那么开发者就不得不更新整个Express</p>
</li>
<li><p>在4.x中，Express摆脱了对Connect的依赖，并且摒弃除了静态文件模块之外的所有中间件，只保留了核心路由处理逻辑以及一些其他的代码</p>
</li>
</ul>
<p>在过去的几年中，Express取得了巨大的成功，无论是开发者的数量还是社区的活跃程度都是现象级的</p>
<p><strong>🔔MEAN架构<code>MongoDB + Express + Angular + Node</code>成为了不少初创网站的开发首选，至今依旧非常流行</strong></p>
<h2 id="Koa"><a href="#Koa" class="headerlink" title="Koa"></a>Koa</h2><p>在某些需要同步调用的场景下处理异步让人窝火，开发者往往会在这上面耗费大量的时间，而不是把主要精力放在业务逻辑上</p>
<p>因此在2013年底，Express的原班开发人马使用ES2015中的新特性，主要是Generator重新打造新的Web框架<code>Koa</code></p>
<p>Koa的初衷就是彻底解决在Node Web开发中的异步问题，在ES2015还没有被Node完全支持的时候，运行Koa项目需要在启动Node时加上<code>--harmony</code>参数</p>
<p><strong>🔔Koa的理念与Connect更加相似，内部没有提供任何中间件，Express中保留的静态文件和路由也被剔除，仅作为中间件调用的脚手架</strong></p>
<p>Koa的发展同样存在Koa1.x和Koa2两个阶段，两者之间有一定的区别</p>
<ul>
<li>Koa2使用ES2017中async方法来处理中间件的调用</li>
<li>Koa1.x使用的是generator</li>
</ul>
<p>Connect、 Express、 Koa这三个框架可谓一脉相承，Connect目前已经少有人问津，Express和Koa占据了绝大部分的市场</p>
<h1 id="内容规划"><a href="#内容规划" class="headerlink" title="内容规划"></a>内容规划</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="上传文章"><a href="#上传文章" class="headerlink" title="上传文章"></a>上传文章</h3><p>实现Web的富文本编译器是一项吃力不讨好的工作，如果独立开发的话，逻辑的复杂性往往会让开发者陷入绝境。因此通常情况下要实现在线文章的编辑往往借用第三方模块</p>
<p>文章实现的博客系统里，采用本地编写文章，然后上传到网站上的方式实现，这能让我们更关注路由和数据库存储方面的内容</p>
<h3 id="路由设计"><a href="#路由设计" class="headerlink" title="路由设计"></a>路由设计</h3><p><strong>👇初步设计的路由</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot.png" alt="screenshot"></p>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p><strong>为了实现目标网站，需要解决👇问题</strong></p>
<ul>
<li>静态文件服务</li>
<li>路由设计</li>
<li>数据存储</li>
<li>页面渲染</li>
</ul>
<p><strong>本次使用的技术栈为<code>Node + Koa + MongoDB + Redis + Ejs</code></strong></p>
<ul>
<li>Node：开发语言</li>
<li>Koa：Web开发框架</li>
<li>MongoDB：基础的数据存储服务</li>
<li>Redis：主要用来存储Session</li>
<li>Ejs：页面模板引擎</li>
</ul>
<h1 id="Koa入门"><a href="#Koa入门" class="headerlink" title="Koa入门"></a>Koa入门</h1><h2 id="Koa1-x与Koa2"><a href="#Koa1-x与Koa2" class="headerlink" title="Koa1.x与Koa2"></a>Koa1.x与Koa2</h2><p><strong>Koa1.x和Koa2的主要区别在于前者使用Generator，后者使用async方法来进行中间件的管理</strong></p>
<p>Web开发中尽管Node本身是异步的，但还是希望能够顺序执行某些操作，而且代码实现要尽可能简洁</p>
<p>在实际开发中这些操作会抽象为一个个中间件，通常都是异步进行调用的，那么问题就回到如何控制中间件的调用顺序</p>
<p>在Koa1.x的版本中，使用了ES2015提案中的Generator函数来作为异步处理的主要方式。为了实现Generator的自动执行，还使用了co模块作为底层的执行器</p>
<p><strong>安装Koa 1.x&amp; Koa 2.x</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%201.png" alt="screenshot 1"></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%204.png" alt="screenshot 4"></p>
<p><strong>Koa 1.x示例</strong></p>
<pre><code class="javascript">var Koa = require(&#39;koa&#39;)
var app = Koa()

app.use(function *(next) {
    var start = new Date
    // 调用下一个中间件，即向前端响应 &#39;hello, world&#39;
    yield next
    var ms = new Date - start
    // 打印从请求到响应的耗时
    console.log(&#39;%s %s - %s&#39;, this.method, this.url, ms)
})

app.use(function *() {
    this.body = &#39;hello, world&#39;
})

app.listen(3000)</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%202.png" alt="screenshot 2"></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%203.png" alt="screenshot 3"></p>
<p>Koa1.x对中间件的处理基于co模块，这仍然是一种比较hack的方法。ES2017的草案里增加async函数，Koa为此发布2.0版本，这个版本舍弃Genrator函数和co模块，完全使用async函数来实现</p>
<p>Koa和Express最大的不同之处在于Koa剥离了各种中间件，这种做法的优点是可以让框架变得更加轻量，缺点就是Koa发展时间还较短，各种中间件质量参差不齐，1.x和2.x的中间件也存在一些兼容性问题，但对于多数常用的中间件来说，都已经实现了对Koa2.0的支持</p>
<p><strong>❗️文章👇提到的Koa均代表Koa2.0</strong></p>
<h2 id="context对象"><a href="#context对象" class="headerlink" title="context对象"></a>context对象</h2><p><strong>使用Koa2.0创建http服务器</strong></p>
<pre><code class="javascript">const Koa = require(&#39;koa&#39;)
const app = new Koa()

app.use(ctx =&gt; {
    ctx.body = &#39;0xGeekCat&#39;
})

app.listen(3000)</code></pre>
<p><strong>Node提供<code>request</code>和<code>response</code>两个对象，Koa把两者封装到<code>context</code>对象中，缩写为<code>ctx</code></strong></p>
<p>context中封装许多方法和属性，大部分是从request和response对象中使用委托方式得来的</p>
<p>ctx也提供直接访问原生对象的手段，<code>ctx.req</code>和<code>ctx.res</code>即代表原生request和response对象</p>
<p>ctx对象还自行封装了一些对象，例如<code>ctx.request</code>和<code>ctx.response</code>，它们和原生对象之间的区别在于里面只有一部分常用的属性</p>
<pre><code class="javascript">const Koa = require(&#39;koa&#39;)
const app = new Koa()

app.use((ctx, next) =&gt; {
    console.log(ctx.request)
    console.log(ctx.response)
})

app.listen(3000)</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%205.png" alt="screenshot 5"></p>
<p><code>ctx.response</code>只有最基本的几个属性，没有注册任何事件或方法，这表示👇的使用方法是错误的</p>
<pre><code class="javascript">fs.createReadStream(&#39;foo.txt&#39;).pipe(ctx.response)</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%206.png" alt="screenshot 6"></p>
<p><code>ctx.response</code>只是一个简单的对象，没有定义任何事件，要使用pipe方法，代码要改成👇</p>
<pre><code class="javascript">fs.createReadStream(&#39;foo.txt&#39;).pipe(ctx.res)</code></pre>
<h3 id="ctx-state"><a href="#ctx-state" class="headerlink" title="ctx.state"></a>ctx.state</h3><p>state属性是官方推荐的命名空间，如开发者想把后端的消息传递到前端，可以将属性挂在<code>ctx.state</code>下面</p>
<p>例如从数据库中查找一个用户id</p>
<pre><code class="javascript">ctx.state.user = await User.find(id)</code></pre>
<h3 id="其他的一些属性和方法"><a href="#其他的一些属性和方法" class="headerlink" title="其他的一些属性和方法"></a>其他的一些属性和方法</h3><pre><code class="javascript">ctx.app // ctx 对 app 对象的引用
ctx.cookie.get(name, [option]) // 获得 cookie
ctx.cookie.set(name, value, [option]) // 设置 cookie
ctx.throw([msg], [status], [properties]) // 用来抛出异常</code></pre>
<h3 id="处理http请求"><a href="#处理http请求" class="headerlink" title="处理http请求"></a>处理http请求</h3><p>Koa在<code>ctx</code>对象中封装了request以及response对象，那么在处理http请求的时候，使用ctx就可以完成所有的处理</p>
<pre><code class="javascript">ctx.body = &#39;0xGeekCat&#39;
👇 等效
res.statusCode = 200
res.end(&#39;0xGeekCat&#39;)</code></pre>
<p>ctx相当于<code>ctx.request</code>或者<code>ctx.response</code>的别名，http请求类型通过<code>ctx.method</code>判断，get请求的参数可以通过<code>ctx.query</code>获取</p>
<p><strong>设置路由获取get请求参数</strong></p>
<pre><code class="javascript">const Router = require(&#39;koa-router&#39;)
const Koa = require(&#39;koa&#39;)

const app = new Koa()
const router = new Router()

router.get(&#39;/&#39;, async (ctx, next) =&gt; {
    console.log(ctx.method)
    console.log(ctx.query)
})

app.use(router.routes())
app.listen(3000)</code></pre>
<p>访问<code>http://127.0.0.1:3000/?name=0xGeekCat</code>时console回显</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%207.png" alt="screenshot 7"></p>
<p>Koa处理get请求比较简单，直接通过<code>ctx.query.﹤param﹥</code>就能拿到get参数的值，post请求的处理稍微麻烦一些，通常使用<code>bodyParser</code>中间件进行处理，但也仅限于普通表单，获取格式为<code>ctx.request.body.﹤param﹥</code></p>
<pre><code class="javascript">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Login&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;http://localhost:3000/login&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><strong>服务端相应路由的代码</strong></p>
<pre><code class="javascript">var Koa=require(&#39;koa&#39;)
var router = require(&#39;koa-router&#39;)()
var bodyParser = require(&#39;koa-bodyparser&#39;)

var app=new Koa();

router.post(&#39;/login&#39;, (ctx, next) =&gt; {
    console.log(ctx.request.body.name)
    console.log(ctx.request.body.password)
})


app.use(bodyParser());
app.use(router.routes());
app.listen(3000);</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%208.png" alt="screenshot 8"></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%209.png" alt="screenshot 9"></p>
<h1 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h1><h2 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h2><p>在介绍Koa中间件之前，暂时先把目光投向Express，因为Koa中间件的设计思想大部分来自Connect，而Express又是基于Connect扩展而来</p>
<p><strong>🔔Express本身是由路由和中间件构成，从本质上来说Express的运行就是在不断调用各种中间件</strong></p>
<p><strong>中间件本质上是接收请求并且做出相应动作的函数</strong>，该函数通常接收<code>req</code>和<code>res</code>作为参数，以便对request和response对象进行操作，在Web应用中，客户端发起的每一个请求，首先要经过中间件的处理才能继续向下</p>
<p>中间件的第三个参数一般写作<code>next</code>，代表下一个中间件。如果在中间件的方法体中调用<code>next</code>方法，即表示请求会由下一个中间件处理</p>
<p><strong>👇这个函数就可以做为中间件</strong></p>
<pre><code class="javascript">function md(req, res, next) {
    console.log(&#39;I am a Middleware&#39;)
    next()
}</code></pre>
<h3 id="中间件的功能"><a href="#中间件的功能" class="headerlink" title="中间件的功能"></a>中间件的功能</h3><p>中间件本质仍然是函数，那么它就可以做到Node代码能做到的任何事情，除此之外还包括了修改request和response对象、终结请求-响应循环，以及调用下一个中间件等功能，这通常是通过内部调用<code>next</code>方法实现。如果在某个中间件中没有调用<code>next</code>方法，则表示对请求的处理到此为止，下一个中间件不会被执行</p>
<h3 id="中间件的加载"><a href="#中间件的加载" class="headerlink" title="中间件的加载"></a>中间件的加载</h3><p>中间件的加载使用<code>use</code>方法实现，该方法定义在Express或者Koa对象的实例上</p>
<p><strong>例如加载👆定义的中间件<code>md</code></strong></p>
<pre><code class="javascript">var app = new Koa()
app.use(md)</code></pre>
<h3 id="Express中的中间件"><a href="#Express中的中间件" class="headerlink" title="Express中的中间件"></a>Express中的中间件</h3><p>Express应用可使用👇几种中间件</p>
<ul>
<li>应用级中间件</li>
<li>路由级中间件</li>
<li>错误处理中间件</li>
<li>第三方中间件</li>
</ul>
<p>这是官网的分类，实际上这几个概念有一些重合之处</p>
<h4 id="应用级中间件"><a href="#应用级中间件" class="headerlink" title="应用级中间件"></a>应用级中间件</h4><p>使用<code>app.use</code>方法或者<code>app.METHOD()</code>，调用绑定在app对象上的中间件，这里Method表示http方法，即get / post等</p>
<pre><code class="javascript">const express = require(&#39;express&#39;)
var app = express()

// 没有挂在路径的中间件，前端每个请求都会经过该中间件
app.use(function (req, rees, next) {
    console.log(&#39;Time:&#39;, Date.now())
    next()
})

app.use(&#39;/user/:id&#39;, function (req, res, next) {
    console.log(&#39;Request Type:&#39;, req.method)
})

app.listen(3000)</code></pre>
<p>访问<code>http://127.0.0.1:3000/user/1</code></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2010.png" alt="screenshot 10"></p>
<p>第一个中间件中调用了<code>next</code>方法，因此会转到第二个中间件，第二个由于没有调用<code>next</code>方法，其后的中间件都不会执行</p>
<h4 id="路由级中间件"><a href="#路由级中间件" class="headerlink" title="路由级中间件"></a>路由级中间件</h4><p>和Koa不同，路由处理是Express的一部分，通常通过<code>router.use</code>方法绑定到router对象上</p>
<pre><code class="javascript">const express = require(&#39;express&#39;)
var app = express()
var router = express.Router()

// 将中间件挂载道 /login 路径下，所有访问 /login 的请求都会经过该中间件
router.use(&#39;/login&#39;, function (req, res, next) {
    console.log(&#39;Time:&#39;, Date.now()) 
    next()
})

app.use(router) 👈
app.listen(3000)</code></pre>
<p>访问<code>http://127.0.0.1:3000/login</code></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2011.png" alt="screenshot 11"></p>
<h4 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h4><p><strong>❗️错误处理中间件有4个参数，即使不需要通过<code>next</code>方法来调用下一个中间件，也必须在参数列表中声明它，否则中间件会被识别为一个常规中间件，不能处理错误</strong></p>
<pre><code class="javascript">const express = require(&#39;express&#39;)
var app = express()

app.get(&#39;/err&#39;,(req,res)=&gt;{
    throw new Error(&quot;0xGeekCat&quot;);
})

app.use((err,req,res,next)=&gt;{
    console.log(err)
    res.status(500).send(&#39;Something broke&#39;);
})

app.listen(3000)</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2012.png" alt="screenshot 12"></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2014.png" alt="screenshot 14"></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2013.png" alt="screenshot 13"></p>
<h4 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h4><p>从4.x版本开始，Express不再依赖Connect。除负责管理静态资源的static模块的中间件外，Express以前内置的中间件已经全部作为单独模块安装使用</p>
<h4 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h4><p>第三方中间件可以为Express应用增加更多功能，通常通过<code>npm</code>来安装</p>
<p>Koa没有任何内置中间件，连路由处理都没有包括在内，所有中间件都要通过第三方模块来实现，比起Express来，Koa更像是Connect</p>
<h2 id="next方法"><a href="#next方法" class="headerlink" title="next方法"></a>next方法</h2><p>无论是Express还是Koa，中间件的调用都是通过<code>next</code>方法来执行的，该方法最早在Connect中提出，并被Express和Koa沿用</p>
<ol>
<li>调用<code>app.use</code>方法时，在内部形成了一个中间件数组，在框架内部会将执行下一个中间件的操作放在next方法内部</li>
<li>当执行next方法时，就会执行下一个中间件</li>
<li>如果在一个中间件中没有调用next方法，那么中间件的调用会中断，后续的中间件都不会被执行</li>
</ol>
<p>对于整个应用来说，next方法实现的无非就是嵌套调用，可以理解成一个递归操作，执行完<code>next</code>对应的中间件后，还会返回原来的方法内部，继续向下执行后面的方法</p>
<p>👇<code>洋葱图</code>很形象地解释了Koa中间件的工作原理，对于request对象，首先从最外围的中间件开始一层层向下，到达最底层的中间件后，再由内到外一层层返回给客户端。每个中间件都可能对request或者response对象进行修改</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2015.png" alt="screenshot 15"></p>
<h2 id="中间件的串行调用"><a href="#中间件的串行调用" class="headerlink" title="中间件的串行调用"></a>中间件的串行调用</h2><p>👇是Koa设计的核心部分，在Web开发中，通常希望一些操作能够串行执行，例如等待写入日志完成后再进行数据库操作，最后再进行路由处理，在技术层面，上面的业务场景表现为串行调用某些异步中间件</p>
<p><strong>Express的异步中间件</strong></p>
<pre><code class="javascript">var app = require(&#39;express&#39;)()

app.use(function (req, res, next) {
    next()
    console.log(&#39;I am middleware1&#39;)
})

app.use(function (req, res, next) {
    process.nextTick(function () { 👈
        console.log(&#39;I am middleware2&#39;)
        next()
    })
})

app.listen(3000)</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2016.png" alt="screenshot 16"></p>
<p>根据👆提到next方法可以理解为递归操作，那么应该先执行输出middleware2，然后再输出middleware1；但由于第二个中间件内的<code>process.nextTick</code>是异步调用，因此马上返回到第一个中间件，然后第二个中间件的回调函数才执行</p>
<p>在有些情况下，可能需要等待middleware2执行结束之后再输出结果。<strong>在Koa中借助<code>async / await</code>方法即可轻松实现</strong></p>
<p><strong>Koa中使用async组织的异步中间件</strong></p>
<pre><code class="javascript">var Koa = require(&#39;koa&#39;)
var app = new Koa()

app.use(async (ctx, next) =&gt; {
    await next()
    console.log(&#39;I am middleware1&#39;)
})

app.use(async (ctx, next) =&gt; {
    process.nextTick(function () {
        console.log(&#39;I am middleware2&#39;)
        next()
    })
})

app.listen(3000)</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2017.png" alt="screenshot 17"></p>
<p>使用await关键字后，直到next内部的异步方法完成之前，midddlware1都不会向下执行</p>
<h2 id="如何实现超时响应"><a href="#如何实现超时响应" class="headerlink" title="如何实现超时响应"></a>如何实现超时响应</h2><h3 id="Express中的超时响应"><a href="#Express中的超时响应" class="headerlink" title="Express中的超时响应"></a>Express中的超时响应</h3><p>在Web开发中，开发者希望能给长时间得不到响应的请求返回特定的错误信息</p>
<p>在Express中，可以使用<code>connect-timeout</code>第三方中间件来处理响应超时</p>
<pre><code class="javascript">var express = require(&#39;express&#39;)
var timeout = require(&#39;connect-timeout&#39;)

var app = express()

app.use(timeout(&#39;5s&#39;))
app.use(some middleware)
app.use(haltOnTimedout)
app.use(some middleware)
app.use(haltOnTimedout)

function haltOnTimedout(req, res, next) {
    if (!req.timedout)
        next()
}

app.listen(3000)</code></pre>
<p>该中间件的实现很简单，timeout内部定义了定时器方法，如果超过定时器规定的时间限制，就会触发错误事件并返回503状态码，并且<code>haltOnTimedout</code>后面的中间件不再执行；如果在定时器触发前完成响应，就会取消定时器</p>
<p>这种做法虽然看起来能解决超时问题，但缺点也很明显，timeout方法中只定义了简单的定时器，如果中间件中包含异步操作那么容易在调用回调方法时出现问题</p>
<p>假设timeout加载后又引入了一个名为<code>queryDB</code>的中间件，该中间件封装了一个异步的数据库操作，并且将查询的结果作为响应消息返回。<code>queryDB</code>在大多数状态下执行很快，1秒内就能完成，但有时会因为某些原因，例如被其他操作阻塞导致执行时间变成10秒，这时timeout中间件已经将超时信息返回给客户端，如果<code>queryDB</code>内部包含<code>res.send</code>方法，就会出现<code>Can&#39;t set headers after they are sent</code>的错误</p>
<p>要解决这个问题，比较妥当的方式是通过事件监听的方式，如果超时之后触发该事件，那么取消之后的全部操作，或者直接修改<code>res.end</code>方法，在其中设置<code>flag</code>用来判断是否已经调用过</p>
<p>问题的根本原因是<code>connect-time</code>或者是Express没办法对异步中间件的执行进行很好的控制</p>
<h3 id="Koa中的超时响应"><a href="#Koa中的超时响应" class="headerlink" title="Koa中的超时响应"></a>Koa中的超时响应</h3><p>借助async方法中间件会按照顺序来执行，这时进行timeout管理就比较方便，社区也有<code>koa-timeout</code>等中间件</p>
<pre><code class="javascript">var Koa = require(&#39;koa&#39;)
var app = new Koa()

app.use(async (ctx, next) =&gt; {
    var tmr = null
    const timeout = 5000

    await Promise.race([new Promise(function (resolve, reject) {
        tmr = setTimeout(function () {
            var e = new Error(&#39;Request timeout&#39;)
            e.status = 408
            reject(e)
        }, timeout)
    }),
        new Promise(function (resolve, reject) {
            // 执行后面加载的中间件
            (async function () {
                await next()
                clearTimeout(tmr)
                resolve()
            })()
        })
    ])
})</code></pre>
<p><strong>❌此知识点没有太理解</strong></p>
<h1 id="常用服务的实现"><a href="#常用服务的实现" class="headerlink" title="常用服务的实现"></a>常用服务的实现</h1><h2 id="静态文件服务"><a href="#静态文件服务" class="headerlink" title="静态文件服务"></a>静态文件服务</h2><p>之前学习使用原生http和fs模块结合的方法实现静态文件服务，在Web开发中通常不会使用自己封装的方法，这里选择<code>koa-static</code>作为处理静态文件的中间件</p>
<pre><code class="javascript">const Koa = require(&#39;koa&#39;);
const app = new Koa();
const server = require(&#39;koa-static&#39;)

app.use(server(__dirname + &#39;/static/html&#39;, {extensions: [&#39;html&#39;]}))
app.listen(3000)</code></pre>
<p>static模块规划好静态文件存放的路径，使用<code>app.use</code>挂载在应用上即可</p>
<p>👆<code>__dirname + &quot;/static/html&quot;</code>表示静态文件存放的路径，当接收到请求后，会在该路径下进行查找</p>
<p><code>serve</code>方法可以接收一个对象作为参数，表示将查找文件的范围限定在指定后缀名范围内。例如👆代码设置<code>{extensions: [&#39;html&#39;]}</code>，那么在访问文件时就可以省略文件后缀名</p>
<p><strong>👇通过<code>http://127.0.0.1:3000/login</code>访问<code>login.html</code></strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2018.png" alt="screenshot 18"></p>
<p><strong><code>login.html</code>所在文件位置</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2019.png" alt="screenshot 19"></p>
<h2 id="路由服务"><a href="#路由服务" class="headerlink" title="路由服务"></a>路由服务</h2><p>Express的路由中间件集成在框架内部</p>
<pre><code class="javascript">const express = require(&#39;express&#39;)
const app = new express

app.get(&#39;/&#39;, function (req, res) {
    // todo
})</code></pre>
<p><strong>Koa中的路由处理要借助第三方模块来实现，👇使用<code>koa-router</code></strong></p>
<pre><code class="javascript">const Koa = require(&#39;koa&#39;);
const bodyParser = require(&#39;koa-bodyparser&#39;)
const router = require(&#39;koa-router&#39;)()
const app = new Koa()

app.use(bodyParser())
app.use(router.routes())

router.get(&#39;/&#39;, async (ctx, next) =&gt; {
    ctx.response.body =
        &#39;&lt;h1&gt;Index&lt;/h1&gt; &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;&#39; +
        &#39;&lt;p&gt;Name: &lt;input name=&quot;name&quot;&gt;&lt;/p&gt;&#39; +
        &#39;&lt;p&gt;Password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/p&gt;&#39; +
        &#39;&lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/p&gt;&#39; +
        &#39;&lt;/form&gt;&#39;
})

router.post(&#39;/login&#39;, async (ctx, next) =&gt; {
    let name = ctx.request.body.name || &#39;&#39;,
        password = ctx.request.body.password || &#39;&#39;

    console.log(ctx.request)

    if (name === &#39;0xGeekCat&#39; &amp;&amp; password === &#39;12345&#39;) {
        ctx.body = &#39;Success&#39;
    } else {
        ctx.body = &#39;Error&#39;
    }
})

app.listen(3000)</code></pre>
<p>👆定义两个路由，接收到get请求后向前端渲染一个form表单用于登录，当用户单击submit提交后，router接收到post请求后使用<code>ctx.request.body</code>对象解析表单中的字段，该对象是router中间件提供的访问接口</p>
<p><strong>因为router也是中间件，因此要使用<code>app.use</code>挂在app对象中，‼️<code>bodyPaser</code>要在router之前加载才能生效</strong></p>
<p><code>koa-router</code>同样支持定义多种形式的路由</p>
<pre><code class="javascript">router.get(&#39;/:category/:title&#39;, function (ctx, next) {
    console.log(ctx.param)
})</code></pre>
<p><code>:category</code>和<code>:title</code>实际上起到get参数的作用，要获取这种形式的参数，可以使用<code>ctx.params</code>对象</p>
<pre><code class="javascript">router.get(&#39;/delete/blog/:blogId&#39;, async (ctx, next) =&gt; {
    await dbAPI.deleteBlogId(ctx.params.blogId)
    await next()
})</code></pre>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>在网站的规划中，使用id这一唯一属性来定位一篇博客，而博客是以HTML文件形式存储在static文件夹下的，文件名是博客的标题</p>
<p>为了管理id和文件名以及文件分类之间的映射关系，引入MongoDB来作为数据存储的介质</p>
<h3 id="使用Mongoose访问MongoDB"><a href="#使用Mongoose访问MongoDB" class="headerlink" title="使用Mongoose访问MongoDB"></a>使用Mongoose访问MongoDB</h3><p>在SSH<code>struts2 + spring + hibernate</code>框架开发的J2EE应用中，<code>Hibernate</code>是一种ORM对象关系映射<code>Object Relational Mapper</code>，它提供了Java对象与关系型数据库表的映射关系，使得开发者能编写更高效率的代码而不是直接使用JDBC来连接数据库</p>
<p>在这一点上，Mongoose和Hibernate相似，它同样为Node提供访问MongoDB的接口，它将MongoDB中的collection映射到Node的代码中</p>
<p>Mongoose和Hibernate的不同之处在于Mongoose是一种ODM对象文件映射<code>Object Document Mapper</code>，提供的是对象和文档数据库<code>Document Database</code>之间的映射关系</p>
<h3 id="Mongoose的使用"><a href="#Mongoose的使用" class="headerlink" title="Mongoose的使用"></a>Mongoose的使用</h3><p><strong>安装mongoose</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2020.png" alt="screenshot 20"></p>
<p><strong>MongoDB的本地实例运行</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2021.png" alt="screenshot 21"></p>
<p><strong>连接MongoDB</strong></p>
<pre><code class="javascript">var mongoose = require(&#39;mongoose&#39;);
mongoose.connect(&#39;mongodb://localhost/test&#39;, { useUnifiedTopology: true, useNewUrlParser: true }); 👈 没有这个options会报错</code></pre>
<p><strong>检测连接状态</strong></p>
<pre><code class="javascript">var db = mongoose.connection

db.on(&#39;error&#39;, console.error.bind(console, &#39;connection error&#39;))
db.once(&#39;open&#39;, function (callback) {
    // connected
})</code></pre>
<p>Mongoose自身定义了一些数据结构来实现Node代码与MongoDB的映射</p>
<p>要使用Monggose，首先要明确schema、model的概念</p>
<ul>
<li>schema：一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力</li>
<li>model：由schema发布生成的模型，具有抽象属性和行为的数据库操作对</li>
</ul>
<p>如果使用关系型数据库来类比的话，schema大致相当于关系型数据库中的一张表，每个schema中定义若干字段；而model则可以看作是SQL语句的抽象，只能定义在一个schema上，MongoDB的增删改查操作都是通过model来进行的</p>
<p><strong>在数据库中定义一个名为login的collection，它包含两个字段：username、password</strong></p>
<pre><code class="javascript">var mongoose = require(&#39;mongoose&#39;);
mongoose.connect(&#39;mongodb://localhost/test&#39;, { useUnifiedTopology: true, useNewUrlParser: true });

var db = mongoose.connection

var loginSchema = new mongoose.Schema({
    username: String,
    password: String
})

var login = db.model(&#39;login&#39;, loginSchema, &#39;login&#39;) 👈
var user1 = new login({username: &#39;0xGeekCat&#39;, password: &#39;12345&#39;})
user1.save(function (err) {
    if (err)
        return handleError(err)
})</code></pre>
<p>👆首先声明一个schema，schema内有username和password两个字段，schema相当于collection的骨架</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2022.png" alt="screenshot 22"></p>
<p>该方法的第三个参数才是MongoDB中对应collection的名字</p>
<pre><code class="javascript">var login = db.model(&#39;login&#39;, loginSchema)</code></pre>
<p><strong>👆如果漏掉第三个参数，❗️Mongoose会自动创建一个名为<code>logins</code>的collection，相当于model名称的复数形式，那么之后在使用collection的时候就会发现一个预期之外的collection</strong></p>
<p>定义好model之后，调用model的save方法将数据存储在对应的collection中</p>
<p><strong>使用Mongoose查询</strong></p>
<pre><code class="javascript">var login = db.model(&#39;login&#39;, loginSchema, &#39;login&#39;)
var query = login.find({username: &#39;0xGeekCat&#39;})
query.then(function (doc) {
    console.log(doc)
})</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2023.png" alt="screenshot 23"></p>
<p>doc对象是一个包含所有结果集的数组</p>
<p>此外Mongoose是默认支持Promise规范的，这就代表我们可以用ES201X的一些新语法来编写数据库代码</p>
<h3 id="博客系统的数据库准备"><a href="#博客系统的数据库准备" class="headerlink" title="博客系统的数据库准备"></a>博客系统的数据库准备</h3><p>在编写代码之前，首先要明确有哪些数据需要存储。除了存储登录信息外，还需要维护关于博客信息的collection</p>
<ul>
<li>title：文章标题</li>
<li>kind：文章分类</li>
<li>id：文章id</li>
</ul>
<p>本节定义的collection中，只维护一张信息表，至于博客文章的内容本身，暂且将它们视为静态文件放在<code>static/blogs</code>文件夹下</p>
<h3 id="Schema的定义"><a href="#Schema的定义" class="headerlink" title="Schema的定义"></a>Schema的定义</h3><p>在目前的实现中一共定义了两个collection，分别是login和blogList</p>
<ul>
<li>login负责登录</li>
<li>blogList用作博客相关的操作</li>
</ul>
<pre><code class="javascript">var mongoose = require(&#39;mongoose&#39;);
mongoose.connect(&#39;mongodb://localhost/test&#39;, { useUnifiedTopology: true, useNewUrlParser: true });

var db = mongoose.connection
var blogListSchema = new mongoose.Schema({
    title: String,
    kind: String,
    id: String
})

var blogList = db.model(&#39;blogList&#39;, blogListSchema, &#39;blogList&#39;)</code></pre>
<h3 id="数据查询的实现"><a href="#数据查询的实现" class="headerlink" title="数据查询的实现"></a>数据查询的实现</h3><p><strong>数据查询分为两个阶段</strong></p>
<ol>
<li>数据库查询并返回结果</li>
<li>前端页面根据返回的json字符串渲染对应的页面元素</li>
</ol>
<p>当访问博客网站时，首先会被默认导航至首页，即博客列表。这里以文章的分类作为条件进行查询，如果用户没有选择任何分类，则返回全部文章</p>
<p><strong>查询某个分类下的全部文章</strong></p>
<pre><code class="javascript">var blogList = db.model(&#39;blogList&#39;, blogListSchema, &#39;blogList&#39;)

async function getBlogList(kind) {
    let query = {} // 空对象作为查询条件，表示查询所有结果
    let results = []

    if (kind !== &#39;/&#39;) {
        query = {kind: kind}
    }

    results = await blogList.find(query)
    return results
}</code></pre>
<p>该方法返回一个包含着若干对象的数组，可以直接用来被前端解析</p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><strong>处理文件的上传，大致分为两步</strong></p>
<ul>
<li>路由收到前端的post请求，将文件存储在static目录下</li>
<li>将form中的文件名、类别信息写入数据库，并赋给这篇博客一个用于访问的id</li>
</ul>
<p>文件的上传使用<code>formidable</code>实现，<code>formidable</code>是一个著名的处理文件上传的第三方模块，被广泛地用在Node Web应用中</p>
<pre><code class="javascript">// uplaod.js
const formidable = require(&#39;formidable&#39;)
const fs = require(&#39;fs&#39;)

function dealUpload(ctx) {
    var form = new formidable.IncomingForm() 
    form.keepExtensions = true // 保持原来的扩展名
    form.uploadDir = __dirname + &#39;/static/html&#39;
    form.parse(ctx.req, function (err, fields, files) {
        if (err)
            throw err
        fs.renameSync(files.file.path, form.uploadDir + files.file.name)

        // todo save to db
    })
}

module.exports = dealUpload</code></pre>
<p>下一步是将博客信息写入数据库，我们计划给每一篇博客增加id，这一属性是从1开始自增的，因此在插入新的数据前，要获取数据库中最大的id</p>
<p><strong>查找ID的最大值</strong></p>
<pre><code class="javascript">var blogList = db.model(&#39;blogList&#39;, blogListSchema, &#39;blogList&#39;)

async function queryMaxID() {
    let temp = 0
    await blogList.find({}).sort({&#39;id&#39;: -1}).limit(1).then(function (doc) {
        if (doc.length &gt; 0) {
            temp = doc[0].id
        } else {
            console.log(&#39;collection is empty&#39;)
        }
    })
    return temp
}

async function insertBlogList(title, kind) {
    let value = await queryMaxID()
    var record = new blogList({title: title, kind: kind, id: ++value})
    record.save(function (err) {
        if (err) {
            console.log(err)
            return 
        }
        console.log(&#39;Insert done&#39;)
    })
}</code></pre>
<p>👆使用了两个async方法，<code>queryMaxID</code>方法使用了一条链式查询</p>
<pre><code class="javascript">blogList.find({}).sort({&#39;id&#39;: -1}).limit(1)</code></pre>
<p><strong>❗️mongodb中没有其他数据库里的max或者min方法来取最大值和最小值，惯用的做法是先按照id进行排序，然后取第一条</strong></p>
<p><code>sort()</code>方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式</p>
<ul>
<li>1 为升序排列</li>
<li>-1是为降序排列</li>
</ul>
<h3 id="对文章的修改"><a href="#对文章的修改" class="headerlink" title="对文章的修改"></a>对文章的修改</h3><p>由于没有实现一个线上的文本编辑器，因此操作只能局限在删除一篇文章或者修改文章的分类</p>
<p><strong>配置路由</strong></p>
<pre><code class="javascript">router.post(&#39;/delete/blog/:blogId&#39;, async (ctx, next) =&gt; {
    // todo delete someone blog
    await next()
})

router.post(&#39;/modify/blog/:blogId/:kindName&#39;, async (ctx, next) =&gt; {
    // todo modify blog kind
    await next()
})</code></pre>
<p><strong>删除和修改blog的分类</strong></p>
<pre><code class="javascript">// delete未定义async方法
function deleteBlogId(id) {
    let query = {id: id}
    console.log(query)
    blogList.remove(query).then(function (doc) {
        console.log(&#39;done&#39;)
    })
}

function modifyBlogKind(id, kind) {
    let query = {id: id}
    blogList.findOneAndUpdate(query, {kind: kind}).then(function (doc) {
        console.log(&#39;done&#39;)
    })
}</code></pre>
<h3 id="使用MongoDB存储文件内容"><a href="#使用MongoDB存储文件内容" class="headerlink" title="使用MongoDB存储文件内容"></a>使用MongoDB存储文件内容</h3><p>在目前的系统中，将文章以静态文件的形式存放在目录下，在实践中通常是不安全的，通常需要将其存在数据库中，博客文章存储在数据库中通常还要经过加密，这里省略这一步</p>
<p>本章的网站采取用户本地上传的做法，那么在用户上传成功后，就要将文件内容写入数据库中</p>
<pre><code class="javascript">async function saveBlog(path, id) {
    let content = require(&#39;fs&#39;).readFileSync(path, {encoding: &quot;UTF-8&quot;})
    let query = new blog({content: content, id: id})
    query.save(function (err) {
        if (err)
            return
        console.log(&#39;save done&#39;)
    })
}</code></pre>
<p><strong>修改upload.js</strong></p>
<pre><code class="javascript">form.parse(ctx.req, async function (err, fields, files) {
    if (err)
        throw err
    fs.renameSync(files.file.path, form.uploadDir + files.file.name)
    let value = await dbAPI.insertBlogList(files.file.name, fields.kind)
    console.log(&#39;Id is&#39;, value)

    await dbAPI.saveBlog(form.uploadDir, fields.kind)
})</code></pre>
<h3 id="文章内容的读取"><a href="#文章内容的读取" class="headerlink" title="文章内容的读取"></a>文章内容的读取</h3><p>当用户单击页面元素试图打开文章时，我们需要用id作为参数在数据库中进行查询</p>
<pre><code class="javascript">async function readBlog(id) {
    let content
    await blog.find({id: id}).then(function (doc) {
        content = doc[0]
    })

    return content
}</code></pre>
<p>在MongoDB中，整片文章都是使用字符串的形式来存储的，对于Koa而言，直接使用👇方法就能在前端返回文章内容</p>
<pre><code class="javascript">ctx.body = content</code></pre>
<p><strong>打开博客内容的路由设计</strong></p>
<pre><code class="javascript">router.get(&#39;/blog/:blogId&#39;, async (ctx, next) =&gt; {
    let blogId = ctx.params.blogId
    ctx.body = await dbAPI.readBlog(blogId)
    await next()
})</code></pre>
<h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><p>目前市面上流行的前端解决方案大致有👇几种：</p>
<ul>
<li>不使用任何框架，直接使用Ajax请求后端，再根据返回的结果对DOM进行操作，这种做法很少见</li>
<li>使用页面模板方式来渲染页面，比较流行的是ejs、jade等几种模板引擎，其原理大都是通过使用正则替换来生成HTML</li>
<li>使用完整的前端框架，近几年前端流行MVVM框架，比较出名的有React、 Angular、Vue等</li>
</ul>
<p>使用前端渲染，通常需要一个页面引擎，它的本质是一个正则表达式，将引擎定义的标签和后端返回的数据转换成HTML标签本节选择ejs来作为模板引擎，它通过将JavaScript代码嵌入到HTML文件中来实现，其文件扩展名为.ejs</p>
<h3 id="在Koa中使用ejs"><a href="#在Koa中使用ejs" class="headerlink" title="在Koa中使用ejs"></a>在Koa中使用ejs</h3><p>首先安装<code>koa-views</code>模块，这是一个比较完整的包含多种页面模板的第三方模块</p>
<p><strong>在root.js中增加👇代码</strong></p>
<pre><code class="javascript">const views = require(&#39;koa-views&#39;)

app.use(views(__dirname + &#39;/static/html&#39;), {extensions: [&#39;html&#39;]})</code></pre>
<p><strong>在route.js中调用render方法进行渲染</strong></p>
<pre><code class="javascript">router.get(&#39;/blogList&#39;, async (ctx, next) =&gt; {
    const result = await dbAPI.getBlogList(&#39;/&#39;)
    return ctx.render(&#39;blogList&#39;, {results: results})
})</code></pre>
<p>在<code>ctx.render</code>方法之前需要加上return关键字，render方法接收两个参数</p>
<ul>
<li>第一个参数是ejs文件的名字，其路径已经定义在root.js中</li>
<li>第二个参数是一个对象，属性名表示ejs文件中变量的名字，属性名必须和ejs中的定义的变量名相同，否则会出现解析错误</li>
</ul>
<p><strong>blogList.ejs代码</strong></p>
<pre><code class="ejs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;blogList&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;ul&gt;
    &lt;% for(var i=0;i&lt;results.length;i++){%>
        <li id="<%= results[i].id %>" class="<%= results[i].kind %>"><%= results[i].title %></li>
    <%}%&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>👆将文章的id作为dom元素的id，文章的类别作为元素的class属性，当用户单击了某一篇文章后，可以直接使用对应的id来作为http请求的参数进行查询</p>
<h3 id="根据id打开文件"><a href="#根据id打开文件" class="headerlink" title="根据id打开文件"></a>根据id打开文件</h3><p>现在页面上显示了博客列表，接下来要做的就是打开某一篇具体的文章，现在在页面上有每一篇文章的id，只需要在单击时将id信息打包发出即可，可以使用<code>﹤a/﹥</code>标签或者<code>jQuery</code>来实现，这里选择<code>jQuery</code></p>
<pre><code class="javascript">&lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(&quot;li&quot;).click(function(){
        $.get(&quot;/blog/&quot;+$(this).attr(&#39;id&#39;), function(result){
            console.log(&quot;done&quot;);
        });
    });
&lt;/script&gt;</code></pre>
<h3 id="前端渲染和后端渲染"><a href="#前端渲染和后端渲染" class="headerlink" title="前端渲染和后端渲染"></a>前端渲染和后端渲染</h3><ul>
<li><strong>前端渲染是指后端提供<code>restful API</code> ，前端只负责调用API并拿到json数据，然后根据拿到的数据更新页面视图或者其他的一些操作</strong>，如果开发者在项目中使用了ejs或者jade这样的页面模板，那么通常属于前端渲染<ul>
<li>优点是可以实现前后端分离和前端的模块化，事实上近些年涌现的React或者Vue都是以前端渲染为前提的</li>
<li>缺点是SEO不友好</li>
</ul>
</li>
<li><strong>服务器一次性返回全部的HTML字符串，这种方式被称为后端渲染</strong>；使用字符串拼接的HTML往往会耗费开发者全部的耐心<ul>
<li>这种方式的优点是首屏加载快对SEO有利</li>
<li>缺点是前后端耦合，代码难以维护而且不美观</li>
</ul>
</li>
</ul>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2024.png" alt="screenshot 24"></p>
<h1 id="构建健壮的Web应用"><a href="#构建健壮的Web应用" class="headerlink" title="构建健壮的Web应用"></a>构建健壮的Web应用</h1><h2 id="上传文件验证"><a href="#上传文件验证" class="headerlink" title="上传文件验证"></a>上传文件验证</h2><p>允许用户上传文件其实是很危险的操作，因为你无法期望所有用户都能上传有效合法的文件，因此有必要对上传文件进行验证</p>
<h3 id="限制文件类型"><a href="#限制文件类型" class="headerlink" title="限制文件类型"></a>限制文件类型</h3><p>对于博客网站文件类型通常只有js/html/css三种类型的后缀名，再加上一些图片后缀或者pdf，系统应当对上传文件的后缀名进行检查，如果不是上述类型的文件名后缀，应该拒绝服务并返回错误码。对文件类型的验证通常在客户端完成</p>
<h3 id="限制文件大小"><a href="#限制文件大小" class="headerlink" title="限制文件大小"></a>限制文件大小</h3><p>对于网站来说，通常在任何情况下都应该避免大文件的上传，如果服务器对上传的文件没有进行正确的处理，很容易就会出现内存不足的情况，过大的文件也会浪费服务器磁盘空间</p>
<p><strong>验证文件的大小可以通过两个方面来进行</strong></p>
<ul>
<li>在客户端上传之前就对文件大小进行判断</li>
<li>在服务器端进行处理时进行验证</li>
</ul>
<p><strong>前端验证文件类型和大小</strong></p>
<pre><code class="html">&lt;form id=&quot;form1&quot; action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;uploadFile&quot;/&gt;&lt;br/&gt;
    &lt;input type=&quot;text&quot; name=&quot;kind&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;submit&quot; id=&quot;sbtn&quot; onclick = &quot;submitForm();&quot;/&gt;
&lt;/form&gt;
&lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    function submitForm(){
        var uploadFile = document.getElementById(&quot;uploadFile&quot;);
        var file = uploadFile.files[0];
        var type = file.type;//例如 text/html
        var fileSize = file.size;
        //文件大小超过100k
           if(fileSize &gt; 100 * 1024 || type!== &quot;text/html&quot;){
              alert(&quot;file type/size error,please check.&quot;)
               return;
           }
        $(&quot;#form1&quot;).submit();
    }
&lt;/script&gt;</code></pre>
<p><strong>服务器端验证上传文件大小</strong></p>
<pre><code class="javascript">function dealUpload(ctx) {
    if (ctx.method === &#39;POST&#39; &amp;&amp; ctx.path === &#39;/upload&#39;) {
        let form = new formidable.IncomingForm()
        form.maxFileSize = 100 * 1024
        form.keepExtensions = true
        form.uploadDir = __dirname + &#39;/static/blogs&#39;

        ...

        form.on(&#39;error&#39;, function (e) {
            console.log(e)
            res.writeHead(400, {
                &#39;Connection&#39;: &#39;close&#39;
            })

            res.end(&#39;file is too big&#39;)
        })
    }
}</code></pre>
<p>如果上传的字节超过一定大小就拒绝接收并返回错误码，由于恶意访问者有可能篡改前端代码，因此后端的验证也是必需的</p>
<p><code>formidable</code>模块可以做到这一点，该模块使用流来处理上传的文件。在处理文件流的过程中可以获得已上传的文件大小，如果超过预定义的<code>maxFileSize</code>值就会触发error事件并停止接收文件，此时返回给客户端错误消息</p>
<p><strong>‼️<code>formidable</code>在npm上的<code>1.1.1</code>版本，在这个版本中设置maxFileSize不会生效，即使检测到了文件大小超出限制也不能取消上传</strong></p>
<p><strong>👇个人使用的<code>formidable</code>版本</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2025.png" alt="screenshot 25"></p>
<h2 id="使用Cookie进行身份验证"><a href="#使用Cookie进行身份验证" class="headerlink" title="使用Cookie进行身份验证"></a>使用Cookie进行身份验证</h2><p>现在开发出来的站点是无状态的。在大型项目中的权限系统总是问题最多并且最难管理</p>
<h3 id="关于Cookie"><a href="#关于Cookie" class="headerlink" title="关于Cookie"></a>关于Cookie</h3><p><strong>Cookie是为了辨别用户信息而存储在客户端的数据</strong></p>
<p>对于Cookie的使用，最重要的就是要控制Cookie的大小，不要放入无用的信息或者过多信息；无论使用何种服务端技术，只要发送的HTTP响应中包含👇形式的字段，则视为服务器要求客户端设置Cookie</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2026.png" alt="screenshot 26"></p>
<p>支持Cookie的浏览器都会对此做出反应，即创建Cookie文件并保存，也可能是放在内存中，用户以后在每次发出请求时，浏览器都要判断当前所有的Cookie中有没有处于有效期，根据expires属性判断；并且匹配path属性的Cookie信息，如果有的话，会以下面的形式加入到请求头中发回服务端</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2027.png" alt="screenshot 27"></p>
<h3 id="Node中的Cookie"><a href="#Node中的Cookie" class="headerlink" title="Node中的Cookie"></a>Node中的Cookie</h3><p>Node设置Cookie很简单，response对象提供了原生的Cookie方法</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2028.png" alt="screenshot 28"></p>
<h3 id="Koa中的Cookie"><a href="#Koa中的Cookie" class="headerlink" title="Koa中的Cookie"></a>Koa中的Cookie</h3><p>Koa中对Cookie的操作本质上还是对Node原生方法的封装</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2029.png" alt="screenshot 29"></p>
<p><strong>在博客系统中，主要针对用户登录进行Cookie设置</strong></p>
<pre><code class="javascript">router.post(&#39;/login&#39;, async (ctx, next) =&gt; {
    console.log(&#39;get&#39;)
    let name = ctx.request.body.name || &#39;&#39;,
        password = ctx.request.body.password || &#39;&#39;
    const result = await dbAPI.validate(name, password)

    if (result) {
        ctx.cookie.set(&#39;loginStatus&#39;, true)
        ctx.redirect(&#39;/blogList&#39;)
    } else {
        ctx.body = &#39;body error&#39;
    }
})</code></pre>
<p>👆设置名为<code>LoginStatus</code>的Cookie，之后要做的就通过Cookie来验证登录状态</p>
<pre><code class="javascript">function validateStatus(ctx) {
    if (!ctx.cookies.get(&#39;loginStatus&#39;)) {
        console.log(&#39;not login&#39;)
        ctx.redirect(&#39;/status/html/login.html&#39;)
    }
}</code></pre>
<p>按照通常的思路，<code>validateStatus</code>方法应该放在<code>route.js</code>中，在收到路由请求后调用</p>
<pre><code class="javascript">router.get(&#39;/&#39;, async (ctx, next) =&gt; {
    validateStatus()
    ctx.redirect(&#39;/blogList&#39;)
})</code></pre>
<p>但这样做的缺点很明显，那就是在每一个路由方法中都要调用该函数，这样会带来很多重复代码。更好的做法是将其用中间件的方式来加载，这样每个路由请求都会经过该中间件</p>
<p><strong>将登录验证作为中间件来实现</strong></p>
<pre><code class="javascript">function validateCookie(ctx, next) {
    if (!ctx.cookies.get(&#39;loginStatus&#39;) &amp;&amp; ctx.url !== &#39;/login&#39;) {
        console.log(&#39;not login&#39;)
        ctx.redirect(&#39;/login&#39;)
    } else
        return next()
}

module.exports = validateCookie</code></pre>
<p>👆中间件首先尝试获取名为<code>loginStatus</code>的Cookie，如果没有设置，就将请求重定向到<code>/login</code>路径</p>
<p>❗️在判断时需要加上<code>ctx.url !== &quot;/login&quot;</code>的判断，否则当用户第一次访问<code>/login</code>时，由于没有还设置cookie，就会造成循环重定向，最后在浏览器中显示一个重定向次数过多的错误</p>
<p>然后在<code>root.js</code>中挂载该中间件，❗️<strong>应该在路由中间件之前加载，每个路由请求在处理前都要进行登录验证</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2030.png" alt="screenshot 30"></p>
<p>当访问<code>localhost:3000</code>时，由于没有cookie浏览器页面会跳转到<code>localhost:3000/login</code></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2031.png" alt="screenshot 31"></p>
<h2 id="使用Session记录会话状态"><a href="#使用Session记录会话状态" class="headerlink" title="使用Session记录会话状态"></a>使用Session记录会话状态</h2><p>关于Session，不应混淆的是<strong>Session规范</strong>和<strong>Session实现</strong></p>
<p><strong>🔔Session与其说是一种规范，不如说是一种概念，表示用户从进入到离开网络应用这段时间内产生的动作以及上下文</strong></p>
<p>Session并不是HTTP的独创，而是广泛地体现在各种网络应用和数据库操作中</p>
<ul>
<li>例如使用FTP协议传输文件，那么从登录到下载文件完成然后离开的这段时间就可以称为一个Session</li>
<li>从拿起电话到拨号然后打完电话离开也是一个Session，而且更接近其语义上的概念(会话)。</li>
</ul>
<p>Session主要用来管理用户状态，例如用户对某个网站页面的设置，或者在上个页面中做的一些操作，这些数据也可以放在Cookie中，但是一来会增加传输的数据量，二是有些数据存在Cookie中并不安全，例如电商网站的交易信息等</p>
<h3 id="HTTP中的Session"><a href="#HTTP中的Session" class="headerlink" title="HTTP中的Session"></a>HTTP中的Session</h3><p>以打电话为例，HTTP服务器就像和多数的用户同时打电话，然而每次说完一句话，服务器就会忘记电话那端是谁，这样的话和多个用户的通话就会带来混乱</p>
<p>早期的HTTP应用是不可交互的，用户只能浏览静态页面，此时用户状态的问题还没有暴露出来；随着互联网的发展，出现了更复杂的交互式应用，但这时HTTP协议已经获得广泛的应用，想推翻重来是不现实的</p>
<p><strong>因此对于HTTP协议来说，折中的方法就是利用Cookie来实现Session</strong></p>
<p>既然Cookie每次都要随着HTTP请求发给服务器，那么只要给每个Cookie一个唯一id，就能知道请求来自哪一用户了，就像👆打电话的例子，只要每个用户在最后说一下自己的名字，服务器就能知道电话那端是谁</p>
<h3 id="创建Session"><a href="#创建Session" class="headerlink" title="创建Session"></a>创建Session</h3><p><strong>一般来说，创建一个Session可以分为👇几步</strong></p>
<ol>
<li>生成一个<code>Session id</code>，这个标识符是唯一的</li>
<li>将<code>Session id</code>存储在内存里；实际上调用代码生成<code>Session id</code>后，其自然是位于内存中的，<strong>❗️不过如果服务器一旦断电或重启，<code>Session</code>信息就会丢失，因此通常使用一些其他技术来进行持久化，例如Redis</strong></li>
<li>将带有<code>Session id</code>的Cookie发送给客户端</li>
</ol>
<h3 id="在Koa中使用Session"><a href="#在Koa中使用Session" class="headerlink" title="在Koa中使用Session"></a>在Koa中使用Session</h3><p>在Koa中使用Session可以考虑使用<code>koa-session</code>中间件</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2032.png" alt="screenshot 32"></p>
<p>其中<code>app.keys</code>代表加密用的密钥</p>
<p><strong>👇测试<code>koa-seesion</code></strong></p>
<pre><code class="javascript">const session = require(&#39;koa-session&#39;)
const Koa = require(&#39;koa&#39;)
const app = new Koa()
const router = require(&#39;koa-router&#39;)()
// app.keys = [&#39;Key&#39;] 👈 如果CONFIG的signed字段为false就不需要设置keys

const CONFIG = {
    key: &#39;login&#39;,
    maxAge: 86400000,
    overwrite: true,
    httpOnly: true,
    signed: false
}
app.use(session(CONFIG, app))

router.get(&#39;/&#39;, (ctx, next) =&gt; {
    ctx.session.login = true 👈 没有这行代码无法正常生成Cookie
    ctx.body = &#39;0xGeekCat&#39;
})

app.use(router.routes())

app.listen(3000, function () {
    console.log(&#39;listening on 3000&#39;)
})</code></pre>
<p><strong>❗️由于Cookie的设置是跟在HTTP响应之后，也就是说要设置一个用作Session的Cookie</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2033.png" alt="screenshot 33"></p>
<p>👆这行代码生成Cookie，Cookie之后会随着<code>HTTP response</code>发送到客户端</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2034.png" alt="screenshot 34"></p>
<p>可以看到value字段的值是一个看似随机的字符串，这就是之后要使用的<code>Session id</code></p>
<p>👇可以设置一个其他路由，检测一下服务器端的Session是否在正常工作</p>
<pre><code class="javascript">router.get(&#39;/verify&#39;, (ctx, next) =&gt; {
    ctx.body = ctx.session.login
})</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2035.png" alt="screenshot 35"></p>
<p>👆证明设置的Session已经正常工作</p>
<h1 id="使用Redis进行持久化"><a href="#使用Redis进行持久化" class="headerlink" title="使用Redis进行持久化"></a>使用Redis进行持久化</h1><p>Redis是一个知名的<code>key-value</code>数据库，它由C语言实现，和MongoDB以及其他数据库不同的是Redis是一个<strong>内存数据库</strong></p>
<h2 id="Node和Redis的交互"><a href="#Node和Redis的交互" class="headerlink" title="Node和Redis的交互"></a>Node和Redis的交互</h2><p>npm上有很多用于连接到Redis的第三方模块，👇使用最为流行的<code>node-redis</code>模块</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2036.png" alt="screenshot 36"></p>
<p>安装完成之后连接Redis</p>
<pre><code class="javascript">const redis = require(&#39;redis&#39;)
const client = redis.createClient(&#39;6379&#39;, &#39;127.0.0.1&#39;)

client.on(&#39;error&#39;, function (err) {
    console.log(err)
})

client.on(&#39;ready&#39;, function () {
    console.log(&#39;ready&#39;)
})

client.set(&#39;name&#39;, &#39;0xGeekCat&#39;, redis.print) 👈 ❗️是print不是print()</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2037.png" alt="screenshot 37"></p>
<p>👆连接Redis成功之后，设置了一个key为<code>name</code>，value为<code>0xGeekCat</code>的键值对，可在命令行中查询</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2038.png" alt="screenshot 38"></p>
<h2 id="CURD操作"><a href="#CURD操作" class="headerlink" title="CURD操作"></a>CURD操作</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p><code>node-redis</code>模块提供的API都是对应Redis命令的映射，除了最后的回调函数；模块方法的参数就是对应命令的参数</p>
<p>此外所有的API操作都是异步的，<code>redis.print</code>就是一个回调函数，用于打印命令的执行结果</p>
<p>使用get方法获取设置的值</p>
<pre><code class="javascript">client.get(&#39;name&#39;, function (err, reply) {
    // reply is null when the key is missing
    console.log(reply) → 0xGeekCat
})</code></pre>
<p>如果想要更新数据值，只需再做一次set操作，原有的值就会被覆盖</p>
<h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2039.png" alt="screenshot 39"></p>
<p>👇只会对一个已经存在的key进行设置，并且设置了10s的过期时间，如果Redis中还没有对应的key，回调函数会返回null。如果该key存在，那么会首先修改value的值，在10s后，该key就会被删除</p>
<pre><code class="javascript">client.set(&#39;name&#39;, &#39;0xGeekCat&#39;, &#39;EX&#39;, 10, &#39;XX&#39;, redis.print)</code></pre>
<p><strong>验证set方法的过期时间</strong></p>
<pre><code class="javascript">client.set(&#39;name&#39;, &#39;0xGeekDog&#39;)

client.set(&#39;name&#39;, &#39;0xGeekCat&#39;, &#39;EX&#39;, 10, &#39;XX&#39;, function (err, reply) {
    client.get(&#39;name&#39;, redis.print)
    setTimeout(function () {
        client.get(&#39;name&#39;, redis.print)
    }, 10000)
})</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2040.png" alt="screenshot 40"></p>
<p><strong>❗<code>redis.print</code>的结尾没有<code>()</code>，如果错误的使用<code>()</code>会回显<code>Reply: undefined</code></strong></p>
<p>从输出可以判断设置的key已经过期，被Redis从列表中删除</p>
<h3 id="DEL"><a href="#DEL" class="headerlink" title="DEL"></a>DEL</h3><pre><code class="javascript">client.del(&#39;pass&#39;, redis.print)</code></pre>
<p>如果试图删除一条不存在的数据，会返回一个0值</p>
<h3 id="使用Promise实现同步调用"><a href="#使用Promise实现同步调用" class="headerlink" title="使用Promise实现同步调用"></a>使用Promise实现同步调用</h3><p>和MongoDB相同，Node对Redis的操作也都是异步进行的，这在某些情境下会变得不方便</p>
<p><strong>对于<code>node-redis</code>模块来说，官方推荐的是使用bluebird来进行方法的Promise化</strong></p>
<p>安装bluebird后使用<code>bluebird.promisifyAll</code>来将全部的方法转换为Promise，这个过程十分方便</p>
<pre><code class="javascript">const redis = require(&#39;redis&#39;)
const {Promise} = require(&#39;bluebird&#39;)

Promise.promisifyAll(redis.RedisClient.prototype)
Promise.promisifyAll(redis.Multi.prototype)</code></pre>
<p><strong>set方法的Promise版本</strong></p>
<pre><code class="javascript">const client = redis.createClient() 👈 查看源码得知参数默认值 host &#39;127.0.0.1&#39;, port 6379
client.setAsync(&#39;name&#39;, &#39;0xGeekCat&#39;).then(function (res) {
    console.log(res) → OK
})</code></pre>
<p>将所有方法转换成Promise之后，使用async方法就成了自然而然的选择</p>
<pre><code class="javascript">async function redisTest() {
    await client.setAsync(&#39;name&#39;, &#39;0xGeekCat&#39;)
    let result = await client.getAsync(&#39;name&#39;)
    console.log(result)
}
redisTest() → 0xGeekCat</code></pre>
<h2 id="使用Redis持久化session"><a href="#使用Redis持久化session" class="headerlink" title="使用Redis持久化session"></a>使用Redis持久化session</h2><p>现在开始尝试将Redis用在👆项目中，这个过程中由于相关的文档的缺乏，有时不得不通过阅读源码的方式来得到正确的用法</p>
<p>要使用Redis来存储Session，仍然可以使用<code>koa-session</code>模块来完成</p>
<p>但需要做一些额外的配置，给config增加一个store属性，这是一种类似于Java中接口的设计，只要CONFIG对象声明了该属性，就必须实现set、get和destory方法</p>
<p><strong>👇修改后的config对象</strong></p>
<pre><code class="javascript">const CONFIG = {
    key: &#39;Koa:sess&#39;,
    maxAge: 86400000,
    overwrite: true,
    httpOnly: true,
    signed: false,
    store: {}
}

CONFIG.store.get = async (key) =&gt; {}
CONFIG.store.set = async (key, sess, maxAge) =&gt; {}
CONFIG.store.destroy = async (key) =&gt; {}

router.use(session(CONFIG, app))</code></pre>
<h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p>每次当服务器收到请求时都会触发该方法。作为参数的key值就是客户端的<code>Session id</code>，get方法的作用和👇这句作用相同</p>
<pre><code class="javascript">let key = ctx.cookies.get(&quot;Koa:sess&quot;)</code></pre>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set方法则会在设置session时触发。该方法有三个参数</p>
<ul>
<li>key</li>
<li>sess</li>
<li>maxAge</li>
</ul>
<p>当执行<code>ctx.session.views = ++n</code>时会触发set方法，<code>koa-session</code>模块会自动生成一个key值</p>
<ul>
<li>sess是一个完整的session对象</li>
<li>maxAge是config设置的过期时间</li>
</ul>
<h3 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h3><p>destroy方法则是在主动调用时才会触发，用于删除一条Session记录。</p>
<p><strong>👇观察<code>koa-session</code>在Redis配置下如何工作</strong></p>
<pre><code class="javascript">const session = require(&#39;koa-session&#39;)
const Koa = require(&#39;koa&#39;)
const app = new Koa()
const redis = require(&#39;redis&#39;)
const {Promise} = require(&#39;bluebird&#39;)

Promise.promisifyAll(redis.RedisClient.prototype)
Promise.promisifyAll(redis.Multi.prototype)

const client = redis.createClient()
client.on(&#39;error&#39;, function (err) {
    console.log(err)
})

const CONFIG = {
    key: &#39;Koa:sess&#39;,
    maxAge: 86400000,
    overwrite: true,
    httpOnly: true,
    signed: false,
    store: {}
}

CONFIG.store.get = async (key) =&gt; {
    console.log(&#39;get key:&#39;, key)
    let result = await client.getAsync(key)
    console.log(&#39;get result:&#39;, result)
}
CONFIG.store.set = async (key, sess, maxAge) =&gt; {
    await client.setAsync(key, JSON.stringify(sess))
    console.log(&#39;set key:&#39;, key)
}
CONFIG.store.destroy = async (key) =&gt; {
    console.log(&#39;destroy key:&#39;, key)
}

app.use(session(CONFIG, app))

app.use(async ctx =&gt; {
    if (ctx.path === &#39;/favicon.ico&#39;)
        return
    ctx.session.agent = ctx.header[&#39;user-agent&#39;]
})

app.listen(3000, function () {
    console.log(&#39;listening on port 3000&#39;)
})</code></pre>
<p>使用浏览器访问<code>localhost:3000</code>，可以观察到程序首先调用set方法设置一个Cookie，id的值的来源是<code>http header</code>的<code>user agent</code>属性(JSON格式)，这个<code>key-value</code>键值对随后被写入到Redis</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2041.png" alt="screenshot 41"></p>
<p><strong>继续刷新页面控制器回显👇</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2042.png" alt="screenshot 42"></p>
<p>get方法被调用，打印出key值和value的值</p>
<p>此时注意到服务器又设置了一个新的<code>Session id</code>值，经过试验发现每一次的请求都会分配一个新的<code>Session id</code></p>
<p>那么会产生一个问题，set方法不断将新的<code>Session id</code>写入Redis，那么每次请求都会产生新的<code>Session id</code>，显然会浪费Redis的空间</p>
<p><strong>此时Redis中存储的key值情况</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2043.png" alt="screenshot 43"></p>
<p>这里的key会越来越多，但永远只有一个是有效的，所以针对一个客户连接只需要存储一个有用的<code>Session id</code>就行</p>
<p>此时destroy方法的作用就显示出来了，在get方法后面调用destroy方法删除没用的<code>Session id</code>即可</p>
<pre><code class="javascript">CONFIG.store.get = async (key) =&gt; {
    console.log(&#39;get key:&#39;, key)
    let result = await client.getAsync(key)
    console.log(&#39;get result:&#39;, result)
    await CONFIG.store.destroy(key) 👈
}
CONFIG.store.destroy = async (key) =&gt; {
    await client.delAsync(key)
    console.log(&#39;destroy key:&#39;, key)
}</code></pre>
<p>此时Redis中便只有一个有效<code>Session id</code>存在</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2044.png" alt="screenshot 44"></p>
<p>在Redis中对于一个连接始终保持一个<code>Session id</code>，为了验证这一点可以使用别的浏览器来访问服务器地址，例如<code>firefox</code>，再次查看Redis中存储的<code>Session id</code>会发现多了一个</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2045.png" alt="screenshot 45"></p>
<h2 id="Redis在Node中的应用"><a href="#Redis在Node中的应用" class="headerlink" title="Redis在Node中的应用"></a>Redis在Node中的应用</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>一般来说消息队列有两种场景，利用Redis这两种场景都能够实现</p>
<ul>
<li>生产/消费者模式：生产者生产消息放到队列里，消费者同时监听队列，如果队列里有了新的消息就将其取走，对于单条消息，只能由一个消费者消费</li>
<li>发布者/订阅者模式：发布者向某个频道发布一条消息后，多个订阅者都会收到同一份消息，这和发微博或者朋友圈的效果类似，每个订阅者收到的消息应该都是一样的</li>
</ul>
<p><strong>发布者/订阅者模式</strong></p>
<pre><code class="javascript">// publisher
const redis = require(&#39;redis&#39;)
const client = redis.createClient()

client.on(&#39;ready&#39;, function () {
    console.log(&#39;ready&#39;)

    // 向test频道发布一条信息
    client.publish(&#39;test&#39;, &#39;0xGeekCat&#39;)
})</code></pre>
<pre><code class="javascript">// subscriber
const redis = require(&#39;redis&#39;)
const client = redis.createClient()

client.subscribe(&#39;test&#39;)
client.on(&#39;message&#39;, function (channel, message) {
    console.log(&#39;channel:&#39; + channel, &#39;message:&#39; + message)
})</code></pre>
<h1 id="Koa源码剖析"><a href="#Koa源码剖析" class="headerlink" title="Koa源码剖析"></a>Koa源码剖析</h1><p>本节主要从源码的角度来讲述Koa，尤其是其中间件系统是如何实现的</p>
<p>跟Express相比，Koa的源码异常简洁，Express因为把路由相关的代码嵌入到了主要逻辑中，因此读Express的源码可能长时间不得要领，而直接读Koa的源码几乎没有什么障碍</p>
<p><strong>Koa的主要代码位于koa根目录下的lib文件夹，只有4个文件去掉注释后的源码不到1000行</strong></p>
<ul>
<li>Request.js：对http request对象的封装</li>
<li>Response.js：对http response对象的封装</li>
<li>Context.js：将上面两个文件的封装整合到context对象中</li>
<li>Application.js：项目的启动及中间件的加载</li>
</ul>
<h2 id="Koa的启动过程"><a href="#Koa的启动过程" class="headerlink" title="Koa的启动过程"></a>Koa的启动过程</h2><p><strong>👇Koa应用的大致结构</strong></p>
<pre><code class="javascript">const Koa = require(&#39;koa&#39;)
const app = new Koa()

// load middleware
app.use(...)
app.use(...)
app.use(...)

app.listen(3000)</code></pre>
<p><strong>Koa的启动过程大致分为三个步骤</strong></p>
<ol>
<li>引入Koa模块，调用构造方法新建一个app对象</li>
<li>加载中间件</li>
<li>调用listen方法监听端口</li>
</ol>
<p>逐步来看这三个步骤在源码中的实现</p>
<p>首先是类和构造函数的定义，这部分代码位于Application.js中</p>
<p><strong>Application.js类定义</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2046.png" alt="screenshot 46"></p>
<p><code>Application</code>类继承于Events模块，当调用Koa的构造函数时，会初始化一些属性和方法，例如以context/response/request为原型创建的新的对象，还有管理中间件的middleware数组等</p>
<h2 id="中间件的加载-1"><a href="#中间件的加载-1" class="headerlink" title="中间件的加载"></a>中间件的加载</h2><p>中间件的本质是一个函数，在Koa中该函数通常具有ctx和next两个参数，分别表示封装好的res/req对象以及下一个要执行的中间件，当有多个中间件的时候，本质上是一种嵌套调用，形如之前的洋葱图</p>
<p>Koa和Express在调用上都是通过调用<code>app.use()</code>的方式来加载一个中间件，但内部的实现却大不相同</p>
<h3 id="Application-js中use方法的定义"><a href="#Application-js中use方法的定义" class="headerlink" title="Application.js中use方法的定义"></a>Application.js中use方法的定义</h3><p><strong>👇use方法的定义</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2047.png" alt="screenshot 47"></p>
<p>Koa在application.js中维持了一个middleware的数组，如果有新的中间件被加载，就push到这个数组中，除此之外没有任何多余的操作，相比之下，Express的use方法就麻烦得多</p>
<p>此外该方法中还增加了<code>isGeneratorFunction</code>判断，这是为了兼容Koa1.x的中间件而加上去的</p>
<p>在Koa1.x中中间件都是Generator函数，Koa2使用的async函数是无法兼容之前的代码的，因此Koa2提供了convert函数来进行转换</p>
<h3 id="Application-js对中间件的调用"><a href="#Application-js对中间件的调用" class="headerlink" title="Application.js对中间件的调用"></a>Application.js对中间件的调用</h3><p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2048.png" alt="screenshot 48"></p>
<p>可以看出关于中间件的核心逻辑应该位于compose方法中，该方法是一个名为<code>Koa-compose</code>的第三方模块</p>
<p>该模块只有一个方法compose，调用方式为<code>compose([a, b, c, ...])</code>，该方法接受一个中间件的数组作为参数，<strong>返回的仍然是一个中间件(函数)，可以将这个函数看作是之前加载的全部中间件的功能集合</strong></p>
<h3 id="compose核心方法"><a href="#compose核心方法" class="headerlink" title="compose核心方法"></a>compose核心方法</h3><p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2049.png" alt="screenshot 49"></p>
<p>方法的核心是一个递归调用的<code>dispatch</code>函数，compose的本质仍是嵌套的中间件</p>
<h2 id="listen-方法"><a href="#listen-方法" class="headerlink" title="listen()方法"></a>listen()方法</h2><p>这是app启动过程中的最后一步，事实上👆都是为了app的启动做准备，<strong>整个Koa应用的启动是通过listen方法来完成的</strong></p>
<p><strong>👇application.js中listen方法的定义</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2050.png" alt="screenshot 50"></p>
<p>👆调用了<code>http.createServer</code>方法建立了http服务器，参数为callback方法返回的<code>handleRequest</code>方法</p>
<p><strong><code>handleRequest</code>方法做了两件事</strong></p>
<ul>
<li><p>封装request和response对象</p>
<pre><code class="javascript">const ctx = this.createContext(req, res);</code></pre>
</li>
<li><p>调用中间件对ctx对象进行处理</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2051.png" alt="screenshot 51"></p>
</li>
</ul>
<h2 id="next-与return-next"><a href="#next-与return-next" class="headerlink" title="next()与return next()"></a>next()与return next()</h2><p>在之前自定义的中间件<code>validateCookie</code>中，最后调用<code>next</code>方法来调用下一个中间件(router)，如果将return去掉，再访问<code>localhost:3000/login</code>就会显示<code>not found</code></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2052.png" alt="screenshot 52"></p>
<p>Koa对中间件调用的实现本质上是嵌套的<code>promise.resolve</code>方法</p>
<p><strong>一个简单的中间件模拟示例</strong></p>
<pre><code class="javascript">let ctx = 1

let md1 = function (ctx, next) {
    next()
}

let md2 = function (ctx, next) {
    return ++ctx
}

let p = Promise.resolve(
    md1(ctx, function next() {
        return Promise.resolve( 
            md2(ctx, function next() {
            // more middleware
        }))
    })
)

p.then(function (ctx) {
    console.log(ctx)
})</code></pre>
<p>👆第一行定义的变量ctx，可以将其看作Koa中的ctx对象，经过中间件的处理后，ctx的值会发生相应的变化</p>
<p>定义md1和md2两个中间件，md1没有做任何操作，只调用了next方法，md2则是对ctx执行加一的操作，那么在最后的then方法中，我们期望ctx的值为2</p>
<p>运行代码最后的结果却是<code>undefined</code>，在md1的next方法前加上return关键字后，就能得到正常的结果</p>
<p>在Koa的源码application.js中，<code>handleRequest</code>方法的最后一行</p>
<pre><code class="javascript">return fnMiddleware(ctx).then(handleResponse).catch(onerror);</code></pre>
<p>中的<code>fnMiddleware(ctx)</code>相当👆声明的Promise对象p，被中间件方法修改后的ctx对象被then方法传给<code>handleResponse</code>方法返回给客户端</p>
<p><strong>每个<font color='red'>中间件方法</font>都会返回一个Promise对象，里面包含的是对ctx的修改，通过调用next方法来调用下一个中间件；再通过return关键字将修改后的ctx对象作为resolve的参数返回</strong></p>
<p>如果多个中间件同时操作ctx对象，那么就有必要使用return关键字将操作的结果返回到上一级调用的中间件</p>
<p>这就是为什么需要使用<code>return next()</code>而不是<code>next()</code>。事实上Koa-router或者Koa-static的源码都是使用<code>return next</code>方法</p>
<h2 id="关于Can’t-set-headers-after-they-are-sent"><a href="#关于Can’t-set-headers-after-they-are-sent" class="headerlink" title="关于Can’t set headers after they are sent."></a>关于Can’t set headers after they are sent.</h2><p>这是使用Express或者Koa常见的错误之一</p>
<p>其原因如字面意思，对于同一个HTTP请求重复发送了HTTP HEADER。服务器在处理HTTP请求时会先发送一个响应头(使用writeHead或setHeader方法)，然后发送主体内容(通过send或者end方法)，如果对一个HTTP请求调用了两次writeHead方法，就会出现Can’t set headers after they are sent的错误提示</p>
<pre><code class="javascript">const http = require(&#39;http&#39;)

http.createServer(function (req, res) {
    res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;)
    res.end(&#39;0xGeekCat&#39;)
    res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;)
}).listen(3000)</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2053.png" alt="screenshot 53"></p>
<p>访问<code>localhost:3000</code>就会得到错误信息，这个例子太过直白</p>
<p>👇是一个Express的例子，由于中间件可能包含异步操作，因此有时错误的原因比较隐蔽</p>
<pre><code class="javascript">const express = require(&#39;express&#39;)
const app = express()

app.use(function (req, res, next) {
    setTimeout(function () {
        res.redirect(&#39;/bar&#39;)
    }, 1000)
    next()
})

app.get(&#39;/foo&#39;, function (req, res) {
    res.end(&#39;foo&#39;)
})

app.get(&#39;/bar&#39;, function (req, res) {
    res.end(&#39;bar&#39;)
})

app.listen(3000)</code></pre>
<p>访问<code>http://localhost:3000/foo</code>会产生同样的错误，原因也很简单，在请求返回之后，setTimeout内部的redirect会对一个已经发送出去的response进行修改，就会出现错误</p>
<p>在实际项目中不会像setTimeout这么明显，可能是一个数据库操作或者其他的异步操作，需要特别注意</p>
<h2 id="Context对象的实现"><a href="#Context对象的实现" class="headerlink" title="Context对象的实现"></a>Context对象的实现</h2><p><strong>ctx对象通过委托获得原生方法和属性</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2054.png" alt="screenshot 54"></p>
<p>delegate是一个Node第三方模块，作用是把一个对象中的属性和方法委托到另一个对象上</p>
<p>这个模块的代码同样非常简单，源代码只有100多行；👆代码中，使用了三个方法</p>
<ul>
<li>method：用于委托方法到目标对象上</li>
<li>access：综合getter和setter，可以对目标进行读写</li>
<li>getter：为目标属性生成一个访问器，可以理解成复制了一个只读属性到目标对象上</li>
</ul>
<p>getter和setter这两个方法是用来控制对象的读写属性的</p>
<p><strong>暂不做过多了解</strong></p>
<h3 id="关于动态加载中间件"><a href="#关于动态加载中间件" class="headerlink" title="关于动态加载中间件"></a>关于动态加载中间件</h3><p>在某些应用场景中，开发者可能希望能够动态加载中间件，例如当路由接收到某个请求后再去加载对应的中间件，<strong>但在Koa中这是无法做到的</strong>。Koa应用唯一一次加载所有中间件是在调用listen方法的时候，即使后面再调用app.use方法，也不会生效</p>
<h2 id="Koa的优缺点"><a href="#Koa的优缺点" class="headerlink" title="Koa的优缺点"></a>Koa的优缺点</h2><p>和Express相比，Koa的优势在于精简，它剥离了所有的中间件，并且对中间件的执行做了很大的优化</p>
<p>一个经验丰富的Express开发者想要转到Koa上并不需要很大的成本，唯一需要注意的就是中间件执行的策略会有差异，这可能会带来一段时间的不适应</p>
<p>现在来说说Koa的缺点，<strong>❗️剥离中间件虽然是个优点，但也让不同中间件的组合变得麻烦起来</strong>，Express经过数年的沉淀，各种用途的中间件已经很成熟；而Koa不同，Koa2.0推出的时间还很短，适配的中间件也不完善，有时单独使用各种中间件还好，但一旦组合起来，可能出现不能正常工作的情况</p>
<p>举个例子，如果想同时使用router和views两个中间件，就要在render方法前加上return关键字，和return next()一个道理，对于刚接触Koa的开发者可能要花很长时间才能定位问题所在。再例如<code>koa-session</code>和<code>Koa-router</code>。虽然中间件概念的引入让Node开发变得像搭积木一样，但积木之间如果不能很顺利地拼接在一块的话，也会增加开发成本</p>
<h1 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h1><p>将网站发布到公网上通常要走一些复杂的流程，使用国内的云服务商和域名提供商，还要提供身份信息和备案信息等，对于个人开发者来说，如果嫌这些步骤麻烦，那么建议选择本地部署的方式</p>
<h3 id="使用Localtunnel实现本地部署"><a href="#使用Localtunnel实现本地部署" class="headerlink" title="使用Localtunnel实现本地部署"></a>使用Localtunnel实现本地部署</h3><p>localtunnel是一个有名的npm第三方模块，它可以很容易地将你的本地服务器映射到公网上，而且不用修改DNS或者防火墙设置</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>localtunnel需要全局安装</p>
<pre><code class="javascript">npm install -g localtunnel  </code></pre>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>先把博客系统在本地运行起来，假设本地端口为3000，然后执行<code>lt</code>命令</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%BD%BF%E7%94%A8Koa2%E6%9E%84%E5%BB%BAWeb%E7%AB%99%E7%82%B9/screenshot%2055.png" alt="screenshot 55"></p>
<p>该命令会生成一个随机的域名，开发者可以通过该域名来访问自己的网站</p>
<p>现在就可以使用该域名来访问网站了，不需要任何额外的操作，唯一的缺点可能就是访问比较慢</p>
<p>通过这种方式部署的网站基本上无法进行SEO优化，也没办法支撑高并发，这不仅由开发者的本地机器决定，更是由localtunnel这种模式本身的特点决定的</p>
<h3 id="localtunnel原理"><a href="#localtunnel原理" class="headerlink" title="localtunnel原理"></a>localtunnel原理</h3><p>localhost只用一行命令就能实现外网到内网的访问很不可思议。但实际上所有外网的访问，都要先经过localtunnel.me中转之后，才能到达本地主机上，<strong>也就是说localtunnel.me起到了转发作用，可以将localtunnel.me看作是一个反向代理服务器</strong></p>
<p>localtunnel.me会在内部维护一张映射表，记录着每个开发者本地主机的信息，当收到某个子域名下的请求时，会先在映射表中进行查找，然后将对应的请求或者响应信息转发出去</p>
<p>从本质上说，所有的内网到外网的穿透，都是借助已经部署在公网上的服务器进行中转的，例如一些VPN服务提供商，往往也是通过某台服务器的中转再到达目标网站的</p>
<p>如果localtunnel.me这个网站本身停止了服务，那么开发者本地的localtunnel模块也会变得不可用</p>
<p>这也是为什么这种部署方式很难优化的原因，因为流量不是直接来自用户，而是经过了localtunnel服务器的中转，最直观的感受就是网页打开速度非常慢，这让所有的本地优化都失去了意义。<strong>但如果是访问量比较小的个人网站，这是比较推荐的方式</strong></p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>《新时期的Node.js入门》</p>

        </div>
        <!-- .entry-content -->
        <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="wechat-code"><img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/photos/wechat.png"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85.html" rel="prev">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.1/img/loader/orange.progress-bar-stripe-loader.svg" data-src="" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                《新时期的Node.js入门》学习日记-知识补充</h3>
                <hr>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E4%B9%A6%E5%86%99%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81.html" rel="next">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.1/img/loader/orange.progress-bar-stripe-loader.svg" data-src="" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                《新时期的Node.js入门》学习日记-书写异步代码</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz",
        appKey: "mgOpfzbkHYqU92CV4IDlAUHQ",
        path: window.location.pathname,
        placeholder: "你是我一生只会遇见一次的惊喜 ..."
      })
  }
</script>

      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="https://0xgeekcat.github.io/" class="profile gravatar"><img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/img/custom/avatar.jpg" itemprop="image" alt="0xGeekCat" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="https://0xgeekcat.github.io/" itemprop="url" rel="author">0xGeekCat</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i></p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 0xGeekCat<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2018</p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by <a href="https://2heng.xin/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Mashiro</a>&<a href="https://www.hojun.cn/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Hojun</a>, Powered by Hexo, Hosted by Coding Pages</a>
        </span>
      </p>
    </div>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.1","name":"/video/The-Pet-Girl-of-Sakurasou.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.1","name":"/video/The-Pet-Girl-of-Sakurasou.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <!-- 实现换肤功能 -->

  <div class="skin-menu no-select" id="mainskin" style="position: fixed">
 <div class="theme-controls row-container">
  <ul class="menu-list">
   <li id="white-bg"> <i class="fa fa-television" aria-hidden="true"></i></li>
   <li id="sakura-bg"> <i class="iconfont icon-sakura"></i></li>
   <li id="gribs-bg"> <i class="fa fa-slack" aria-hidden="true"></i></li>
   <li id="KAdots-bg"> <i class="iconfont icon-dots"></i></li>
   <li id="totem-bg"> <i class="fa fa-optin-monster" aria-hidden="true"></i></li>
   <li id="pixiv-bg"> <i class="iconfont icon-pixiv"></i></li>
   <li id="bing-bg"> <i class="iconfont icon-bing"></i></li>
   <li id="dark-bg"> <i class="fa fa-moon-o" aria-hidden="true"></i></li>
  </ul>
 </div>
</div>
<canvas id="night-mode-cover"></canvas>

  <div class="changeSkin-gear no-select">

  <div class="keys" id="setbtn"> 

   <span id="open-skinMenu"> 切换主题 | SCHEME TOOL  

     <i class="iconfont icon-gear inline-block rotating"></i> 

   </span>

  </div>

</div>

  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/img/custom/avatar.jpg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">Mаксим0xGeekCat</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="https://github.com/0xGeekCat" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/%E6%8A%80%E6%9C%AF/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/%E7%94%9F%E6%B4%BB/">
                  <i class="fa fa-file-text-o" aria-hidden="true"></i>
                  生活
                </a>
              </li>
            
              <li>
                <a href="/categories/%E8%BD%AC%E8%BD%BD/">
                  <i class="fa fa-book" aria-hidden="true"></i>
                  转载
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            书单
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/tags/%E5%B7%B2%E8%AF%BB/">
                  <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                  已读
                </a>
              </li>
            
              <li>
                <a href="/tags/%E6%9C%AA%E8%AF%BB/">
                  <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                  未读
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            关于
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  我？
                </a>
              </li>
            
          </ul>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
</body>
</html>