<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">《新时期的Node.js入门》学习日记-常用模块(下) | 0xGeekCat</title>
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "Mаксим0xGeekCat";
  mashiro_option.author_name = "0xGeekCat";
  mashiro_option.site_url = "https://0xgeekcat.github.io/";
  mashiro_option.v_appId = "GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz";
  mashiro_option.v_appKey = "mgOpfzbkHYqU92CV4IDlAUHQ";
  mashiro_option.mathjax = "0";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/images/Konachan.com%20ls%20black_hair%20f%20toriki%20touhou.jpg,https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/images/Konachan.com-293503-ghostblade-long_hair-red_hair-sword-tagme_character-thighhighs-weapon-wlop-scaled.jpg,https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/images/Konachan.com-298784-aeolian_wlop-barefoot-black_hair-braids-ghostblade-headdress-long_hair-ponytail-wlop-scaled.jpg,https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/images/Konachan.com%20-%20227403%20black_hair%20ghostblade%20jade_(wlop)%20japanese_clothes%20kimono%20logo%20realistic%20short_hair%20tattoo%20umbrella%20wlop.jpg,https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/images/Konachan.com-281267-aeolian_wlop-black_hair-bow_weapon-close-ghostblade-green_eyes-logo-long_hair-realistic-watermark-weapon-wink-wlop-scaled.jpg".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop filter-dim">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="https://0xgeekcat.github.io/">
          <img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/img/custom/avatar.jpg">
        </a>
      </div>
      <div class="header-info">
        <p>用来记录我大学最后生涯破釜沉舟力挽狂澜的疯狂学习历程</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="https://github.com/0xGeekCat" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/img/social/github.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=1292881925@qq.com" target="_blank" class="social-github" title="email">
                    <img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/img/social/email.svg">
                  </a>
                </li>
              
            
              
                <li class="wechat">
                  <a href="/#">
                    <img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/img/social/wechat.png">
                  </a>
                  <div class="wechatInner">
                    <img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/img/custom/wechat.jpg">
                  </div>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <div id="video-btn" class="loadvideo videolive">
    </div>
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <span class="sakurasono">Mаксим</span>
            <span class="shironeko">0xGeekCat</span>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    首页
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    归档
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/%E6%8A%80%E6%9C%AF/">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          技术
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/%E7%94%9F%E6%B4%BB/">
                          <i class="fa fa-file-text-o" aria-hidden="true"></i>
                          生活
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/%E8%BD%AC%E8%BD%BD/">
                          <i class="fa fa-book" aria-hidden="true"></i>
                          转载
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    书单
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/tags/%E5%B7%B2%E8%AF%BB/">
                          <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                          已读
                        </a>
                      </li>
                    
                      <li>
                        <a href="/tags/%E6%9C%AA%E8%AF%BB/">
                          <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                          未读
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    关于
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          我？
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
          <header class="entry-header">
            <h1 class="entry-title">《新时期的Node.js入门》学习日记-常用模块(下)</h1>
            <p class="entry-census">0xGeekCat&nbsp;·&nbsp;2020-8-28&nbsp;·&nbsp;<span id="busuanzi_value_page_pv"></span>次阅读</p></p>

            <hr>
          </header>
        
        <div class="entry-content">
          <h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>WebSocket可以看作是HTTP协议的升级版，它同样是基于TCP协议的应用层协议，主要是为了弥补HTTP协议的无持久化和无状态等缺陷而诞生的。WebSocket提供了客户端和服务器之间全双工的通信机制</p>
<h2 id="保持通话"><a href="#保持通话" class="headerlink" title="保持通话"></a>保持通话</h2><p>当客户端发起一个请求时，客户端和服务器之间首先需要建立TCP连接，然后才能使用更高层的HTTP协议来解析数据</p>
<p>HTTP是非持久化的，当用户发起一个request，服务器会随之返回一个response，那么这个HTTP连接就结束了，TCP连接也随之关闭。如果客户端想要继续访问服务器的内容，还需要重新建立TCP连接。对于连续的请求来说，这样会在TCP握手上浪费不少时间</p>
<p>为了改进这一问题，浏览器在请求头里增加了<code>Connection: Keep-Alive</code>字段，当服务器收到带有这一头部的请求时会保持TCP连接不断开，同时也会在response中增加这一字段，<strong>这样浏览器和服务器之间只要建立一次TCP连接就可以进行多次HTTP通信</strong></p>
<p>在HTTP 1.1版本中，<code>Connection: Keep-Alive</code>被加入到标准之中，同时所有的连接都会被默认保持，除非手动指定<code>Connection: Close</code>。此外为了避免无限制的长连接，服务器也会设置一个<code>timeout</code>属性，用来指定该连接最长可以保持时间</p>
<p><code>keep-alive</code>的最大优点在于其避免了多次的TCP握手带来的性能浪费；但还是有一些缺陷，其本质上还是使用HTTP进行通信，对于协议本身没有什么改进</p>
<h2 id="为什么要有WebSocket"><a href="#为什么要有WebSocket" class="headerlink" title="为什么要有WebSocket"></a>为什么要有WebSocket</h2><p>假设要开发一个新闻类网站，该网站会一直将最新的新闻推送到页面上而不需要用户进行刷新操作，在WebSocket之前的HTTP协议中，服务器无法主动向客户端推送数据，对于这种情况有两种解决方案 </p>
<ul>
<li>客户端每隔几秒就发起Ajax请求，如果返回不为空，就将内容展示在页面上</li>
<li>使用长轮询，服务器收到客户端的请求后，如没有新的内容，就保持阻塞，当新内容产生后再发送response给客户端。</li>
</ul>
<p>这两种做法的缺点都很明显。第一种可能客户端发送了很多请求才能得到一个新内容，第二种则是在服务器获得新内容前都无法关闭socket，会占用很多系统资源</p>
<p><strong>WebSocket可以实现浏览器与服务器的全双工通信</strong>，它和传统的jsonp、comet等解决方案不同，不必浏览器发送请求后再由服务器返回消息，而是可以<strong>由服务器主动发起向浏览器的数据传输</strong></p>
<p>WebSocket的请求头和HTTP很相似，👇是一个WebSocket请求头</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-28%20%E4%B8%8B%E5%8D%882.06.53.png" alt="截屏2020-08-28 下午2.06.53"></p>
<p>服务器返回👇消息</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-28%20%E4%B8%8B%E5%8D%882.07.27.png" alt="截屏2020-08-28 下午2.07.27"></p>
<p>在请求头中，Connection字段必须设置成<code>Upgrade</code>，表示客户端希望连接升级，Upgrade字段必须设置<code>websocket</code>，表示希望升级到WebSocket协议</p>
<p><code>Sec-WebSocket-Key</code>是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。服务器会给这个随机的字符串再加上一个特殊字符串<code>258EAFA5-E 914-47DA-95CA-C5AB0DC85B11</code>，然后计算SHA-1摘要，之后进行BASE-64编码，将结果作为<code>Sec-WebSocket-Accept</code>头的值返回给客户端</p>
<p><code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>这一字符串是一个GUID，其本身并没有特别的含义，选择这个字符串的原因只是这个字符串不大可能被<code>WebSocket</code>之外的协议用到</p>
<p><code>Sec-WebSocket-Version</code>表示支持的WebSocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当被弃用</p>
<p><code>Origin</code>字段是可选的，通常用来表示在浏览器中发起此WebSocket连接所在的页面，类似于<code>Referer</code>。但是与Referer不同的是，Origin只包含了协议和主机名称</p>
<h2 id="WebSocket与Node"><a href="#WebSocket与Node" class="headerlink" title="WebSocket与Node"></a>WebSocket与Node</h2><p>在<code>npm</code>中有很多支持WebSocket的第三方模块，此处学习<code>ws</code></p>
<p><strong>JavaScript连接WebScoket</strong></p>
<pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;
    var ws = new WebSocket(&quot;ws://localhost:3004&quot;)
    ws.onopen = function () {
        ws.send(&#39;hello&#39;)
    }
    ws.onmessage = function (msg) {
        console.log(msg.data)
    }
&lt;/script&gt;</code></pre>
<p><strong>WebSocket服务器</strong></p>
<pre><code class="javascript">var WebSocketServer = require(&#39;ws&#39;).Server
wss = new WebSocketServer({port: 3004})
wss.on(&#39;connection&#39;, function (ws) {
    ws.on(&#39;message&#39;, function (message) {
        console.log(&#39;received: %s&#39;, message)
    })
    ws.send(&quot;I&#39;m a message send from a ws server&quot;)
})</code></pre>
<p>👇服务器和控制器回显</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-28%20%E4%B8%8B%E5%8D%883.24.21.png" alt="截屏2020-08-28 下午3.24.21"></p>
<p>![截屏2020-08-28 下午3.24.45](《新时期的Node-js入门》学习日记-常用模块-下/截屏2020-08-28 下午3.24.45.png)</p>
<p>在Node里，比较出名的WebSocket模块还有<code>Socket.IO</code>，常被拿来做在线的聊天或者推送服务</p>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p><code>Stream模块</code>为Node操作流式数据提供了支持。Stream的思想最早见于早期的UNIX，在UNIX中使用<code>|</code>符号会创建一个匿名管道，其本质上也是一个Stream，用于两个程序或者是设备之间的数据传输</p>
<h2 id="Stream的种类"><a href="#Stream的种类" class="headerlink" title="Stream的种类"></a>Stream的种类</h2><p>在Nodejs中，一共有四种基础的stream类型</p>
<ul>
<li><code>Readable</code>：可读流(for example fs.createReadStream())</li>
<li><code>Writable</code>：可写流(for example fs.createWriteStream())</li>
<li><code>Duplex</code>：既可读，又可写(for example net.Socket)</li>
<li><code>Transform</code>：操作写入的数据，然后读取结果，通常用于输入数据和输出数据不要求匹配的场景，例如zlib.createDeflate()</li>
</ul>
<h2 id="Readable-Stream"><a href="#Readable-Stream" class="headerlink" title="Readable Stream"></a>Readable Stream</h2><pre><code class="javascript">var fs = require(&#39;fs&#39;)

var readStream = fs.createReadStream(&#39;foo.txt&#39;, &#39;utf-8&#39;)
readStream.on(&#39;data&#39;, function (data) {
    console.log(data)
})

readStream.on(&#39;close&#39;, function () {
    console.log(&#39;closed&#39;)
})

readStream.on(&#39;error&#39;, function () {
    console.log(&#39;error&#39;)
})</code></pre>
<h2 id="Writeable-Stream"><a href="#Writeable-Stream" class="headerlink" title="Writeable Stream"></a>Writeable Stream</h2><p>write方法同样是异步的，假设我们创建一个可读流读取一个较大的文件，再调用<code>pipe</code>方法将数据通过一个可写流写入另一个位置。如果读取的速度大于写入的速度，那么Node将会在内存中缓存这些数据；缓冲区有大小限制(state.highWatermark)，当达到阈值后，<code>write</code>方法会返回false，可读流也进入暂停状态，当<code>writeable stream</code>将缓冲区清空之后，会触发<code>drain</code>事件，上游的<code>readable</code>重新开始读取数据</p>
<p>🔔<strong>pipe方法相当于在可读流和可写流之间架起了桥梁，使得数据可以通过管道由可读流进入可写流</strong></p>
<p><strong>使用pipe改写的静态文件服务器</strong></p>
<pre><code class="javascript">var http = require(&#39;http&#39;)
var fs = require(&#39;fs&#39;)

var server = http.createServer(function (req, res) {
    if (req.url === &#39;/&#39;) {
        var fileList = fs.readdirSync(&#39;./&#39;)
        res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;})
        res.end(fileList.toString())
    } else {
        var path = &#39;.&#39; + req.url
        var readStream = fs.createReadStream(path).pipe(res)
    }
})

server.listen(3000)
console.log(&#39;Listening on 3000&#39;)

process.on(&#39;uncaughtException&#39;, function () {
    console.log(&#39;got error&#39;)
})</code></pre>
<h2 id="ReadLine"><a href="#ReadLine" class="headerlink" title="ReadLine"></a>ReadLine</h2><p><code>ReadLine</code>是一个Node原生模块，该模块比较不起眼，提供了按行读取Stream中数据的功能</p>
<pre><code class="javascript">var readline = require(&#39;readline&#39;)
var fs = require(&#39;fs&#39;)

var rl = readline.createInterface({
    input: fs.createReadStream(&#39;foo.txt&#39;)
})

rl.on(&#39;line&#39;, function (data) {
    console.log(data)
})

rl.on(&#39;close&#39;, function () {
    console.log(&#39;closed&#39;)
})</code></pre>
<p><code>readLine</code>并没有提供形如<code>new readline()</code>形式的构造方法，而是使用<code>createInterface</code>方法初始化了一个<code>rl</code>对象</p>
<p>如果一个可读流中包含了很多条独立的信息需要逐条处理，这可能是一个消息队列，这时使用<code>readline</code>模块就比较方便</p>
<h2 id="自定义Stream"><a href="#自定义Stream" class="headerlink" title="自定义Stream"></a>自定义Stream</h2><p>在实际开发中，如果想要使用流式API，而原生的Stream又不能满足需求时，可以考虑自定义Stream类，常用的方法是继承原生的Stream类然后做一些扩展</p>
<pre><code class="javascript">var Readable = require(&#39;stream&#39;).Readable
var util = require(&#39;util&#39;)

util.inherits(MyReadable, Readable)

function MyReadable(array) {
    Readable.call(this, {objectMode: true})
    this.array = array
}

MyReadable.prototype._read = function () {
    if (this.array.length) {
        this.push(this.array.shift())
    } else {
        this.push(null)
    }
}</code></pre>
<p>👆实现了名为<code>MyReadable</code>的类，它继承自<code>Readable</code>类，并且接受一个数组作为参数</p>
<p>想要继承<code>Readable</code>类，就要在自定义的类内部实现<code>_read</code>方法，该方法内部使用<code>push</code>方法往可读流添加数据。</p>
<p>当我们给可读流对象注册data事件后，可读流会在nextTick中调用<code>_read</code>方法，并触发第一次data事件，可读流开始读取时机并不在调用构造函数之后，此时data事件还未注册，可能会捕获不到最初的事件，因此可读流开始产生数据的操作是放在nextTick中的，当有消费者从readable中取数据时会自动调用该方法</p>
<p>例子中在_read方法里调用了push方法，该方法用来向可读流中填充数据</p>
<pre><code class="javascript">const array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
const read = new MyReadable(array)

read.on(&#39;data&#39;, function (data) {
    console.log(data)
})

read.on(&#39;end&#39;, function () {
    console.log(&#39;end&#39;)
})</code></pre>
<p><strong>❗️对于自定义Stream的例子并不是很理解，以后再仔细研究</strong></p>
<h1 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h1><p>Node的Events模块只定义了一个类，就是<code>EventEmitter</code>(以下简称Event)，这个类在很多Node本身以及第三方模块中大量使用，通常是用作基类被继承</p>
<h2 id="事件和监听器"><a href="#事件和监听器" class="headerlink" title="事件和监听器"></a>事件和监听器</h2><p>Node程序中的对象会产生一系列的事件，这些对象被称为<strong>事件触发器</strong>；所有能触发事件的对象都是<code>EventEmitter</code>类的实例。<code>EventEmitter</code>定义了<code>on</code>方法</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-28%20%E4%B8%8B%E5%8D%886.00.45.png" alt="截屏2020-08-28 下午6.00.45"></p>
<p><strong>注册一个事件并触发</strong></p>
<pre><code class="javascript">var eventEmitter = require(&#39;events&#39;)

var myEmitter = new eventEmitter()
myEmitter.on(&#39;begin&#39;, function () {
    console.log(&#39;0xGeekCat&#39;)
})

myEmitter.emit(&#39;begin&#39;)</code></pre>
<p>首先初始化了一个<code>EventEmitter</code>实例，然后注册了一个名为<code>begin</code>的事件，之后调用<code>emit</code>方法触发<code>begin</code>事件</p>
<p>用户可以注册多个同名的事件，如果注册两个名为<code>begin</code>的事件，那么它们都会被触发</p>
<p>如果想获取当前的<code>emitter</code>一共注册了哪些事件，可以使用<code>eventNames</code>方法，该方法会输出包括全部事件名称的数组</p>
<pre><code class="javascript">console.log(myEmitter.eventNames())</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-28%20%E4%B8%8B%E5%8D%888.19.04.png" alt="截屏2020-08-28 下午8.19.04"></p>
<p>如果注册了两个同名的<code>event</code>，输出结果也只有一个，该方法的结果集并不包含重复结果</p>
<p>❗️在Node v6.x及之前的版本中，event模块可以通过👇方法引入</p>
<pre><code class="javascript">var myEmitter = process.eventEmitter</code></pre>
<p>在新的版本中这种写法已经被废弃并会抛出一个异常，只能统一由require进行引入，有时能在一些旧版本的第三方模块中还能看到</p>
<h2 id="处理error事件"><a href="#处理error事件" class="headerlink" title="处理error事件"></a>处理error事件</h2><p>由于Node代码运行在单线程环境中，那么运行时出现的任何错误都有可能导致整个进程退出。利用事件机制可以实现简单的错误处理功能</p>
<p>当Node程序出现错误的时候，通常会触发一个错误事件，如果代码中没有注册相应的处理方法，会导致Node进程崩溃退出</p>
<pre><code class="javascript">myEmitter.emit(&#39;error&#39;, new Error(&#39;crash&#39;))</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-28%20%E4%B8%8B%E5%8D%888.31.06.png" alt="截屏2020-08-28 下午8.31.06"></p>
<p>👆Node程序主动抛出了一个error并打印出整个错误栈，相当于</p>
<pre><code class="javascript">throw new Error(&#39;crash&#39;)</code></pre>
<p>如果不想因为抛出一个error而使进程退出，那么可以让<code>uncaughtException</code>事件作为最后一道防线来捕获异常</p>
<pre><code class="javascript">process.on(&#39;uncaughtException&#39;, function () {
    console.log(&#39;got error&#39;)
})

throw new Error(&#39;Error occurred&#39;)</code></pre>
<p>这种错误处理的方式虽然可以捕获异常，避免了进程的退出，但实际上并不值得提倡</p>
<h2 id="继承Events模块"><a href="#继承Events模块" class="headerlink" title="继承Events模块"></a>继承Events模块</h2><p>在实际的开发中，通常不会直接使用Event模块来进行事件处理，而是选择将其作为基类进行继承的方式来使用Event，在Node的内部实现中，凡是提供了事件机制的模块，都会在内部继承Event模块；<code>util.inherits</code>是用来继承的方法</p>
<p>假设要用Node来开发一个网页上的音乐播放器应用，关于播放和暂停的处理，就可以考虑通过继承events模块来实现</p>
<pre><code class="javascript">var util = require(&#39;util&#39;)
var event = require(&#39;events&#39;)

function Player() {
    event.call(this)
}

util.inherits(Player, event) 👈

var player = new Player()

player.on(&#39;pause&#39;, function () {
    console.log(&#39;paused&#39;)
})

player.on(&#39;play&#39;, function () {
    console.log(&#39;playing&#39;)
})

player.emit(&#39;play&#39;)</code></pre>
<p>另一种场景，假设要利用原生的数组来模拟一个消息队列，该队列会在新增消息和弹出消息时触发对应的事件，也可以考虑继承Events模块</p>
<h1 id="多进程服务"><a href="#多进程服务" class="headerlink" title="多进程服务"></a>多进程服务</h1><h2 id="child-process模块"><a href="#child-process模块" class="headerlink" title="child_process模块"></a>child_process模块</h2><p>Node是单线程运行的，这表示潜在的错误有可能导致线程崩溃，<strong>然后进程也会随着退出</strong>，无法做到企业追求的稳定性；另一方面，单进程也无法充分多核CPU，这是对硬件本身的浪费</p>
<p>Node社区本身也意识到了这一问题，于是从0.1版本就提供了<code>child_process</code>模块，用来<strong>提供多[进]程的支持</strong></p>
<h2 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h2><p>会使用指定的command来生成一个新进程，执行完对应的command后子进程会自动退出。该命令返回一个child_process对象，这代表开发者可以通过监听事件来获得命令执行的结果</p>
<p><strong>使用spwan来执行ls命令</strong></p>
<pre><code class="javascript">var spwan = require(&#39;child_process&#39;).spawn
var ls = spwan(&#39;ls&#39;, [&#39;-la&#39;, &#39;/usr&#39;])

ls.stdout.on(&#39;data&#39;, function (data) {
    console.log(&#39;stdout:&#39;, data.toString())
})

ls.stderr.on(&#39;data&#39;, function (data) {
    console.log(&#39;stderr:&#39;, data.toString())
})

ls.on(&#39;close&#39;, function (code) {
    console.log(&#39;child process exited with code&#39;, code)
})</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-28%20%E4%B8%8B%E5%8D%889.24.16.png" alt="截屏2020-08-28 下午9.24.16"></p>
<p>其中<code>spawn</code>的第一个参数虽然是<code>command</code>，但实际接收的却是一个file</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-28%20%E4%B8%8B%E5%8D%889.24.52.png" alt="截屏2020-08-28 下午9.24.52"></p>
<p>在Windows环境中用于<code>ls</code>同含义的命令<code>dir</code>替代后执行代码会出现形如<code>Error: spawn dir ENOENT</code>的错误；原因很简单，这与操作系统本身有关，在Linux中万物皆文件，命令行的命令也不例外，例如<code>ls</code>命令是一个名为<code>ls</code>的可执行文件；而在Windows中并没有名为<code>dir</code>的可执行文件</p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>在Linux环境下，创建一个新进程的本质是复制一个当前的进程，当用户调用fork后，操作系统会先为这个新进程分配空间，然后将父进程的数据原样复制一份过去，父进程和子进程只有少数值不同，例如进程标识符<code>PID</code></p>
<p>❗️对于Node来说，父进程和子进程都有独立的内存空间和独立的V8实例，它们和父进程唯一的联系是用来进程间通信的<code>IPC Channel</code>；此外Node中<code>fork</code>和<code>POSIX</code>系统调用的不同之处在于Node中的<code>fork</code>并不会复制父进程</p>
<p>Node中的<code>fork</code>是上面提到的spawn的一种特例，前面也提到了Node中的fork并不会复制当前进程。多数情况下，fork接收的第一个参数是一个文件名，使用<code>fork(&quot;xx.js&quot;)</code>相当于在命令行下调用<code>node xx.js</code>，并且父进程和子进程之间可以通过<code>process.send</code>方法来进行通信</p>
<p><strong>master.js调用fork来创建一个子进程</strong></p>
<pre><code class="javascript">var child_process = require(&#39;child_process&#39;)
var worker = child_process.fork(&#39;worker.js&#39;, [&#39;args1&#39;])

worker.on(&#39;exit&#39;, function () {
    console.log(&#39;child process exit&#39;)
})

worker.send({hello: &#39;child&#39;})
worker.on(&#39;message&#39;, function (msg) {
    console.log(&#39;from child&#39;, msg)
})</code></pre>
<p><strong>worker.js</strong></p>
<pre><code class="javascript">var begin = process.argv[2]
console.log(&#39;I am worker&#39;, begin)
process.on(&#39;message&#39;, function (msg) {
    console.log(&#39;from parent&#39;, msg)
    process.exit()
})
process.send({hello: &#39;parent&#39;})</code></pre>
<p>fork内部会通过<code>spawn</code>调用<code>process.executePath</code>，即Node的可执行文件地址<code>/usr/local/bin/node</code>来生成一个Node实例，然后再用这个实例来执行fork方法</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-28%20%E4%B8%8B%E5%8D%889.56.52.png" alt="截屏2020-08-28 下午9.56.52"></p>
<h2 id="exec和execFile"><a href="#exec和execFile" class="headerlink" title="exec和execFile"></a>exec和execFile</h2><p>如果开发一种系统，那么对于不同的模块可能会用到不同的技术来实现，例如Web服务器使用Node，然后再使用Java的消息队列提供发布订阅服务，这种情况下通常使用<strong>进程间通信</strong>的方式来实现</p>
<p>但有时开发者不希望使用这么复杂的方式，或者要调用的干脆是一个黑盒系统，即无法通过修改源码来实现进程间通信，这时候往往采用折中的方式，例如通过<code>shell</code>来调用目标服务，然后再拿到对应的输出</p>
<h3 id="execFile方法"><a href="#execFile方法" class="headerlink" title="execFile方法"></a>execFile方法</h3><p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-28%20%E4%B8%8B%E5%8D%8810.06.26.png" alt="截屏2020-08-28 下午10.06.26"></p>
<p>可以看出，<code>execfile</code>和<code>spawn</code>在形式上的主要区别在于execfile提供了一个回调函数，通过这个回调函数可以获得子进程的标准输出/错误流</p>
<p>使用shell进行跨进程调用长久以来被认为是不稳定的，这大概源于人们对控制台不友好的交互体验的恐惧，输入命令后，很可能长时间看不到一个输出，尽管后台可能在一直运算，但在用户看来和死机无异</p>
<p>在Linux下执行<code>exec</code>命令后，原有进程会被替换成新的进程，进而失去对新进程的控制，这代表着新进程的状态也没办法获取了，此外还有shell本身运行出现错误，或者因为各种原因出现长时间卡顿甚至失去响应等情况</p>
<p>Node.js提供了比较好的解决方案，<code>timeout</code>解决了长时间卡顿的问题，<code>stdout</code>和<code>stderr</code>则提供了标准输出和错误输出，使得子进程的状态可以被获取</p>
<h2 id="spawn和execfile的比较"><a href="#spawn和execfile的比较" class="headerlink" title="spawn和execfile的比较"></a>spawn和execfile的比较</h2><p><strong>先写一段简单的C语言代码，并将其命名为<code>example.c</code></strong></p>
<pre><code class="c">#include &lt;stdio.h&gt;

int main()
{
    printf(&quot;%s&quot;, &quot;hello, world&quot;);
    return 5;
}</code></pre>
<p><strong>使用gcc编译该文件</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-28%20%E4%B8%8B%E5%8D%8810.37.54.png" alt="截屏2020-08-28 下午10.37.54"></p>
<p><strong>使用spwan来调用</strong></p>
<pre><code class="javascript">var spawn = require(&#39;child_process&#39;).spawn
var ls = spawn(&#39;/Users/max/Webstorm/test/example&#39;) 👈 

ls.stdout.on(&#39;data&#39;, function (data) {
    console.log(&#39;stdout:&#39;, data.toString())
})

ls.stderr.on(&#39;data&#39;, function (data) {
    console.log(&#39;stderr:&#39;, data.toString())
})

ls.on(&#39;close&#39;, function (code) {
    console.log(&#39;child process exited with code&#39;, code)
})</code></pre>
<p><strong>❗️spawn的执行目录和node所处目录相同，如果是<code>spawn(&#39;example&#39;)</code>程序会报错，除非<code>example</code>程序也位于<code>/usr/local/bin</code>目录</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-28%20%E4%B8%8B%E5%8D%8811.09.01.png" alt="截屏2020-08-28 下午11.09.01"></p>
<p>程序正确打印出了<code>hello,world</code>，此外还可以看到<code>example</code>最后的<code>return 5</code>会被作为子进程结束的<code>code</code>被返回</p>
<p><strong>使用execFile来调用</strong></p>
<pre><code class="javascript">const exec = require(&#39;child_process&#39;).exec
const child = exec(&#39;/Users/max/Webstorm/test/example&#39;, ((error, stdout, stderr) =&gt; {
    if (stderr) 👈 作者似乎写错了 本人在这里进行了修改
        throw stderr
    console.log(stdout)
}))</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-28%20%E4%B8%8B%E5%8D%8811.17.45.png" alt="截屏2020-08-28 下午11.17.45"></p>
<p>同样打印出<code>hello,world</code>，可见除了调用形式不同，二者相差不大</p>
<p>在子进程的信息交互方面，spawn使用流式处理的方式，当子进程产生数据时，主进程可以通过监听事件来获取消息；而exec是将所有返回的信息放在stdout里面一次性返回的，也就是该方法的<code>maxBuffer</code>参数，当子进程的输出超过这个大小时，会产生一个错误</p>
<p>此外注意到spawn有一个名为shell的参数，其类型为一个布尔值或者字符串，如果这个值被设置为<code>true</code>，就会启动一个shell来执行命令，这个shell在<code>UNIX</code>上是<code>bin/sh</code>，在<code>Windows</code>上则是<code>cmd.exe</code></p>
<p><code>exec</code>在内部也是通过调用<code>execFile</code>来实现的，可以从源码中验证这一点，在早期的Node源码中，<code>exec</code>命令会根据当前环境来初始化一个<code>shell</code>，例如<code>cmd.exe</code>或者<code>/bin/sh</code>，然后在<code>shell</code>中调用作为参数的命令</p>
<p>通常<code>execFile</code>的效率要高于<code>exec</code>，这是因为<code>execFile</code>没有启动<code>shell</code>，而是直接调用<code>spawn</code>来实现的</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>👆几个用于创建进程的方法，都属于<code>child_process</code>的类方法，此外<code>childProcess</code>类继承了<code>EventEmitter</code>，在<code>childProcess</code>中引入事件给进程间通信带来很大的便利</p>
<p><strong><code>childProcess</code>中的事件</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-29%20%E4%B8%8A%E5%8D%888.53.59.png" alt="截屏2020-08-29 上午8.53.59"></p>
<p><code>childProcess</code>模块定义的<code>send</code>方法，用于进程间通信</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-29%20%E4%B8%8A%E5%8D%889.01.46.png" alt="截屏2020-08-29 上午9.01.46"></p>
<p>通过<code>send</code>方法发送的消息，可以通过监听<code>message</code>事件来获取</p>
<p><strong>父进程发送一个Socket对象</strong></p>
<pre><code class="javascript">const child = require(&#39;child_process&#39;).fork(&#39;worker.js&#39;)
const server = require(&#39;net&#39;).createServer()

server.on(&#39;connection&#39;, (socket) =&gt; {
    socket.end(&#39;handled by parent&#39;)
})

server.listen(1337, function () {
    child.send(&#39;server&#39;, server)
})</code></pre>
<p><strong>子进程接收socket对象</strong></p>
<pre><code class="javascript">process.on(&#39;message&#39;, function (m, server) {
    if (m === &#39;server&#39;) {
        server.on(&#39;connection&#39;, function (socket) {
            socket.end(&#39;handled by child&#39;)
        })
    }
})</code></pre>
<p><strong>❌此处没有太理解例子</strong></p>
<h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><p><code>child_process</code>的一个重要使用场景是创建多进程服务来保证服务稳定运行</p>
<p>为了统一Node创建多进程服务的方式，Node在0.6之后的版本中增加了<code>Cluster</code>模块，<code>Cluster</code>可以看作是做了封装的<code>child_Process</code>模块。</p>
<p><strong>❗️<code>Cluster</code>模块的一个显著优点是可以共享同一个<code>socket</code>连接，这代表可以使用<code>Cluster</code>模块实现简单的负载均衡</strong></p>
<pre><code class="javascript">const cluster = require(&#39;cluster&#39;)
const http = require(&#39;http&#39;)
const numCPUs = require(&#39;os&#39;).cpus().length

if (cluster.isMaster) {
    console.log(&#39;Master process id is&#39;, process.pid)

    for (let i = 0; i &lt; numCPUs; i++) {
        cluster.fork()
    }

    cluster.on(&#39;exit&#39;, function (worker, code, signal) {
        console.log(&#39;worker process died, id&#39;, worker.process.pid)
    })
} else {
    // Worker可以共享一个TCP连接
    http.createServer(function (req, res) {
        res.writeHead(200)
        res.end(&#39;hello, world\n&#39;)
    }).listen(3000)

    console.log(&#39;Worker started, process id&#39;, process.pid)
}</code></pre>
<p>为了充分利用多核CPU，先调用OS模块的<code>cpus()</code>方法来<strong>获得CPU的核心数</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-29%20%E4%B8%8A%E5%8D%889.33.07.png" alt="截屏2020-08-29 上午9.33.07"></p>
<p>本人电脑为1个6核CPU，但由于电脑操作系统使用了超线程技术，所以实际拥有12个核，从👆代码的运行结果不难看出有12条进程</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-29%20%E4%B8%8A%E5%8D%889.53.50.png" alt="截屏2020-08-29 上午9.53.50"></p>
<p>Cluster模块采用的是经典的<strong>主从模型</strong>，由master进程来管理所有的子进程，可以使用<code>cluster.isMaster</code>属性判断当前进程是master还是worker，其中<strong>主进程不负责具体的任务处理，其主要工作是负责调度和管理</strong>，上面的代码中，所有的子进程都监听<code>3000</code>端口</p>
<p>通常情况下如果多个Node进程监听同一个端口时会出现<code>Error: listen EADDRINUS</code>的错误，而Cluster模块能够让多个子进程监听同一个端口的原因是<strong>master进程内部启动了一个TCP服务器，而真正监听端口的只有这个服务器</strong>，当来自前端的请求触发服务器的connection事件后，master会将对应socket句柄发送给子进程</p>
<h1 id="Process对象"><a href="#Process对象" class="headerlink" title="Process对象"></a>Process对象</h1><p><strong>Process是一个全局对象无须声明即可访问</strong>，每个Node进程都有独立的process对象。该对象中存储当前进程的环境变量</p>
<pre><code class="javascript">console.log(process.getuid()) // 用户ID
console.log(process.argv) // argv[0]表示Node本身 argv[1]表示当前文件路径
console.log(process.pid) // 进程ID
console.log(process.cwd()) // 当前目录
console.log(process.version) // Node版本</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-29%20%E4%B8%8A%E5%8D%8810.02.20.png" alt="截屏2020-08-29 上午10.02.20"></p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><pre><code class="javascript">console.log(process.env)</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-29%20%E4%B8%8A%E5%8D%8810.04.40.png" alt="截屏2020-08-29 上午10.04.40"></p>
<p>开发者可以在代码中判断当前正在运行的Node所属版本，并根据结果来决定是否运行含有一些最新特性的代码</p>
<pre><code class="javascript">var version = process.version

if (version &gt; &quot;v07.6.0&quot;) { 👈 当前版本为V12.18.3 题目的代码在比较中会出现问题
    console.log(&#39;Higher version than v6.0.0&#39;)
}</code></pre>
<h2 id="方法和事件"><a href="#方法和事件" class="headerlink" title="方法和事件"></a>方法和事件</h2><p>process模块定义👇事件</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-29%20%E4%B8%8A%E5%8D%8810.17.22.png" alt="截屏2020-08-29 上午10.17.22"></p>
<p><code>unhandledRejection</code>和<code>uncaughtException</code>通常用做错误处理的最后一层保险，但不代表开发者可以省略具体错误处理的代码，<code>beforeExit</code>比较有意思，它仅会在进程准备退出时触发，<strong>准备退出是指目前的事件循环没有要执行的任务</strong>，如果我们手动捕获这一事件并在回调中增加一些额外动作，<strong>进程就不会退出</strong></p>
<pre><code class="javascript">process.on(&#39;beforeExit&#39;, function () {
    setInterval(function () {
        console.log(&#39;Process will not exit&#39;)
    }, 1000)
})</code></pre>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-29%20%E4%B8%8A%E5%8D%8810.24.57.png" alt="截屏2020-08-29 上午10.24.57"></p>
<pre><code class="javascript">process.on(&quot;exit&quot;, function (code) {
    setInterval(function () {
        console.log(&#39;Process will exit what ever you do&#39;)
    }, 1000)
})

process.exit()</code></pre>
<p>程序直接退出，没有执行<code>exit</code>事件</p>
<h2 id="修改所在的时区"><a href="#修改所在的时区" class="headerlink" title="修改所在的时区"></a>修改所在的时区</h2><p>这个需求可能并不常见，但在某些情况下可能十分有用</p>
<p>假设开发者要向某台服务器提交数据，但没有和该服务器处在同一个时区内，这就导致开发者的时间和服务器的时间可能会相差几个小时，有的服务器会拒绝这样的请求</p>
<p>在旧的版本中，打印<code>date</code>对象返回的是当前时区的时间，但在新版本中直接返回的就是世界时，即<code>greenwich</code>时间，相比东八区要早8个小时，格式也不再是GMT格式，这代表就算要获取当前时间都要做一下额外转换</p>
<p><strong>👇此时实际上为上午10点58分</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-29%20%E4%B8%8A%E5%8D%8811.00.06.png" alt="截屏2020-08-29 上午11.00.06"></p>
<p><strong>使用Date对象提供的全局方法进行转换</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-29%20%E4%B8%8A%E5%8D%8811.03.49.png" alt="截屏2020-08-29 上午11.03.49"></p>
<p><strong><code>getTimezoneOffset</code>的方法可以得到当前的时区</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-29%20%E4%B8%8A%E5%8D%8811.07.32.png" alt="截屏2020-08-29 上午11.07.32"></p>
<p>在上面的代码中，虽然直接打印date对象显示的是<code>greenwich</code>时间，但执行<code>getTimezoneOffset()</code>方法返回的却是<code>-480</code>，表示偏移的分钟数，可以看出偏差8个小时；这代表Node其实知道当前位于哪个时区，但返回的还是<code>greenwich</code>时间</p>
<h3 id="修改timezone"><a href="#修改timezone" class="headerlink" title="修改timezone"></a>修改timezone</h3><p>首先在Date对象的prototype上声明一个map结构作为属性，用于存储时区名称和偏移量的关系，然后对Date类的Date方法进行修改，如果没有声明<code>process.env.TZ</code>变量，就默认返回原来的date对象；如果声明了该属性，就先到对应的数组中进行搜索，然后返回修改后的date对象</p>
<pre><code class="javascript">process.env.TZ = &quot;Asia/Shanghai&quot;;

Date.prototype.TimeZone = new Map([
    [&#39;Europe/London&#39;,0],
    [&#39;Asia/Shanghai&#39;,8],
    [&#39;America/New_York&#39;,-5]
])
Date.prototype.zoneDate = function(){
    if(process.env.TZ === undefined){
        return new Date();
    }else{
        for (let item of this.TimeZone.entries()) {
            if(item[0] === process.env.TZ){
                let d = new Date();
                d.setHours(d.getHours()+item[1]);
                return d;
            }
        }
        return new Date();
    }
}

var date = new Date().zoneDate();
console.log(date);</code></pre>
<p>开发者可能会担心<code>d.getHours()+item[1]</code>会出现大于24的情况，所幸<code>setHours</code>方法已经内置了对这种情况的处理，如果小时的范围小于0或者大于24，会对日期进行相应的加减</p>
<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>Node中的定时器都是全局方法，无须通过require来引入</p>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>使用<code>setTimeout</code>方法最简单的例子是延迟一个函数的执行时间</p>
<pre><code class="javascript">setTimeout(function () {
    console.log(&#39;hello&#39;)
}, 1000)</code></pre>
<p>如果想要在回调执行前清除定时器，可以使用<code>clearTimeout</code>方法</p>
<pre><code class="javascript">var timeout = setTimeout(function () {
    console.log(&#39;hello&#39;)
}, 1000)

clearTimeout(timeout) 👈 hello不会被打印</code></pre>
<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p>如果想要以一个固定的时间间隔运行回调函数，可以使用<code>setInterval</code>方法</p>
<pre><code class="javascript">setInterval(function () {
    console.log(&#39;hello&#39;)
}, 1000)</code></pre>
<p>同样可以用<code>clearInterval</code>方法来清除定时器</p>
<pre><code class="javascript">var i = 0
var interval = setInterval(function () {
    console.log(&#39;hello&#39;)
    if (++i === 5) {
        clearInterval(interval)
    }
}, 1000)</code></pre>
<h3 id="回调函数的参数"><a href="#回调函数的参数" class="headerlink" title="回调函数的参数"></a>回调函数的参数</h3><p>在定时器中，第一个参数是回调方法，第二个参数是定时器的超时时间，其后面还可以定义更多的参数，多余的参数会被作为回调函数的参数</p>
<pre><code class="javascript">setTimeout(function (args) {
    console.log(args)
}, 1000, &#39;timeout&#39;) 👈 一秒后打印timeout</code></pre>
<h2 id="定时器中的this"><a href="#定时器中的this" class="headerlink" title="定时器中的this"></a>定时器中的this</h2><p>在JavaScript中，<code>setTimeout</code>和<code>setInterval</code>中的<code>this</code>均指向Windows。原因也很简单，定时器方法的第一个参数是一个匿名函数，<strong>而JavaScript中所有匿名函数的<code>this</code>都指向Windows</strong></p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-29%20%E4%B8%8A%E5%8D%8811.56.50.png" alt="截屏2020-08-29 上午11.56.50"></p>
<p>在Node中，<code>setTimeout</code>和<code>setInterval</code>的this会指向<code>timeout</code>类，该类在<code>setTimeout</code>和<code>setInterval</code>内部创建并返回，开发者通常不会直接用到两个类，但是可以打印出来</p>
<p><img src="%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97-%E4%B8%8B/%E6%88%AA%E5%B1%8F2020-08-29%20%E4%B8%8A%E5%8D%8811.58.20.png" alt="截屏2020-08-29 上午11.58.20"></p>
<p>如果在<code>setTimeout</code>方法内部涉及<code>this</code>的指向问题，通常会使用<code>bind</code>或者<code>call</code>方法来重新绑定<code>this</code></p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>《新时期的Node.js入门》 李锴</p>

        </div>
        <!-- .entry-content -->
        <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="wechat-code"><img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/photos/wechat.png"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer><!-- .entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E7%94%A8ES6%E4%B9%A6%E5%86%99Node.html" rel="prev">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.1/img/loader/orange.progress-bar-stripe-loader.svg" data-src="" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                《新时期的Node.js入门》学习日记-用ES6书写Node</h3>
                <hr>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/%E3%80%8A%E6%96%B0%E6%97%B6%E6%9C%9F%E7%9A%84Node-js%E5%85%A5%E9%97%A8%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97.html" rel="next">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.1/img/loader/orange.progress-bar-stripe-loader.svg" data-src="" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                《新时期的Node.js入门》学习日记-常用模块(上)</h3>
                <hr>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz",
        appKey: "mgOpfzbkHYqU92CV4IDlAUHQ",
        path: window.location.pathname,
        placeholder: "你是我一生只会遇见一次的惊喜 ..."
      })
  }
</script>

      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="https://schema.org/Person">
          <a href="https://0xgeekcat.github.io/" class="profile gravatar"><img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/img/custom/avatar.jpg" itemprop="image" alt="0xGeekCat" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="https://0xgeekcat.github.io/" itemprop="url" rel="author">0xGeekCat</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i></p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>



    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 0xGeekCat<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2018</p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by <a href="https://2heng.xin/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Mashiro</a>&<a href="https://www.hojun.cn/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Hojun</a>, Powered by Hexo, Hosted by Coding Pages</a>
        </span>
      </p>
    </div>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.1","name":"/video/The-Pet-Girl-of-Sakurasou.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.1","name":"/video/The-Pet-Girl-of-Sakurasou.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <!-- 实现换肤功能 -->

  <div class="skin-menu no-select" id="mainskin" style="position: fixed">
 <div class="theme-controls row-container">
  <ul class="menu-list">
   <li id="white-bg"> <i class="fa fa-television" aria-hidden="true"></i></li>
   <li id="sakura-bg"> <i class="iconfont icon-sakura"></i></li>
   <li id="gribs-bg"> <i class="fa fa-slack" aria-hidden="true"></i></li>
   <li id="KAdots-bg"> <i class="iconfont icon-dots"></i></li>
   <li id="totem-bg"> <i class="fa fa-optin-monster" aria-hidden="true"></i></li>
   <li id="pixiv-bg"> <i class="iconfont icon-pixiv"></i></li>
   <li id="bing-bg"> <i class="iconfont icon-bing"></i></li>
   <li id="dark-bg"> <i class="fa fa-moon-o" aria-hidden="true"></i></li>
  </ul>
 </div>
</div>
<canvas id="night-mode-cover"></canvas>

  <div class="changeSkin-gear no-select">

  <div class="keys" id="setbtn"> 

   <span id="open-skinMenu"> 切换主题 | SCHEME TOOL  

     <i class="iconfont icon-gear inline-block rotating"></i> 

   </span>

  </div>

</div>

  <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/0xGeekCat/cdn@2.2/img/custom/avatar.jpg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">Mаксим0xGeekCat</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="https://github.com/0xGeekCat" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            首页
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            归档
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/%E6%8A%80%E6%9C%AF/">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  技术
                </a>
              </li>
            
              <li>
                <a href="/categories/%E7%94%9F%E6%B4%BB/">
                  <i class="fa fa-file-text-o" aria-hidden="true"></i>
                  生活
                </a>
              </li>
            
              <li>
                <a href="/categories/%E8%BD%AC%E8%BD%BD/">
                  <i class="fa fa-book" aria-hidden="true"></i>
                  转载
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            书单
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/tags/%E5%B7%B2%E8%AF%BB/">
                  <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                  已读
                </a>
              </li>
            
              <li>
                <a href="/tags/%E6%9C%AA%E8%AF%BB/">
                  <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                  未读
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            关于
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  我？
                </a>
              </li>
            
          </ul>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script>
</body>
</html>